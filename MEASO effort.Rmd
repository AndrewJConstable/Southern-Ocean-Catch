---
title: "MEASO fishery statistics - effort"
author: "Andrew Constable"
date: "16/09/2020"
output: 
  bookdown::html_document2:
    toc: true
    toc_depth: 4
    fig_caption: yes
bibliography: '/Users/andreworca/Desktop/_wAAD/_r/Southern-Ocean-Catch/CatchRefs.bibtex'   

---

```{r setup, include=FALSE}
library(knitr)
library(ggplot2)
library(scales)
library(png) # for grabbing dimensions of png files
library(dplyr)
library(raster)
library(rgdal)
library(maptools)
library(sp)
library(measoshapes) # from GitHub  remotes::install_github("AustralianAntarcticDivision/measoshapes")
library(sf)
library(RColorBrewer)
library(SOmap)  #remotes::install_github("AustralianAntarcticDivision/SOmap")
library(geodist)
library(rgeos)
library(colorspace)


knitr::opts_chunk$set(echo = TRUE)


RootDir<-'/Users/andreworca/Desktop/_wAAD/'
WorkDir<-'/Users/andreworca/Desktop/_wAAD/_d/Catch/'

# Editing and Development Notes:
#
# 1. This code is inherited from "MEASO CCAMLR catch data.rmd" which has the basic analyses testing the data.  
            # The code here strips away the testing routines.
#


source("InputData.R")

# Output flags

printMaps<-TRUE
plotCatchMaps <- TRUE
plotToothfish<-TRUE
addIUU<-TRUE

PlotToFile<-TRUE

SOmapTrimLat<--40
SOmapFixBreaks<-FALSE

# distribution of catches by which areas

AreaGroups<-c("MEASO")  # add ASD if need both


# decades for reporting

decade<-seq(1960,2010,10)



################# load functions #####################

source("fnBaseRules.R") # the rules for dividing ASD catch and effort between MEASO areas
source("fnCatch_summary.R")
source("fnDepthArea.R")
source("fnCalcMEASO_TimeSeries_Effort.R")
source("fnCalcMEASO_TimeSeries.R")
source("fnDistributeDepVar.R")
source("fnSetupCatchDistRule.R")
source("fnCatchDistRule.R")
source("fnPropInMareaForRule.R")


fnYmax<-function(m){# m is the maximum catch
  om<-floor(log10(m)) # order of magnitude
 if((m*10^(-om))>5) cInt<-10^om else cInt<-0.5*10^om
 return(c(ceiling(m/cInt)*cInt,cInt))
  } # end function



```

# Introduction  
  
The analysis presented here focusses on the bottom trawling, longlining and potting.  It uses the rules for allocating catches to bottom water fisheries and to MEASO areas to determine the total bottom fishing effort in MEASO areas.  
It tailors the code from the catch analyses specifically to analyse the effort data.  It is assumed that pelagic/midwater trawls do not have ground gear, weighing the trawl to the bottom, event though they may have caught bentho-pelagic species.
Conversely, records identified as bottom trawls or otter trawls generally, were identified as bottom trawls, even if there were substantial krill catches.  


# CCAMLR Statistical Bulletin  
  
The CCAMLR Statistical Bulletin 2019 contains catch and effort records for fisheries up to the 2017-2018 split year. It comprised separate catch and effort files, along with files containing data on each of the factors.    
    
Each of the variables in the CCAMLR Statistical Bulletin (CSB) tables are described here along with a printout of the levels in each.
The dataset kept for the effort analysis is CEdata.

Relevant variables are

**AFE_ID** Unique identifier for the related record in AGGREGATED FISHERY EFFORT (system generated)[this identifier is in both catch data and effort data and used to link the two tables - it is called the AFC_IC in the catch table.]

**Flag_CTY_Code**  ISO 3 code for the flag of the fishing vessel(s).[in both catch and effort tables]  

**Calendar_Year**  Calendar year (YYYY) when fishing occurred.[in both catch and effort tables]  

**Month**  Month (MM) when fishing occurred.[in both catch and effort tables]  

**GAR_Code**  Geographic area code for the statistical area, subarea or division where fishing occurred. [in both catch and effort tables]  

**Target_TXN_Code**  3 alpha code for target taxon.[in both catch and effort tables]  

**GTY_Code**  Code for the gear used during fishing.[in both catch and effort tables]  

**FAC_Code**  Code for the fishing activity.[in both catch and effort tables]  

**VSZ_Code**  Code for the size category of fishing vessels based on gross tonnage.[in both catch and effort tables]  

**Fishing_Hours**  Total number of hours of fishing.[only in effort table]  

**Fishing_Days**  Total number of days during which fishing occurred.[only in effort table]  

**Vessel_Count**  Total number of vessels fishing.[only in effort table]  

**Haul_Count**  Total number of hauls made during fishing.[only in effort table]  

**Hook_Count**  Total number of hooks set. Applies to longline fishing only.[only in effort table]  

**Pot_Count**  Total number of pots set. Applies to pot fishing only.[only in effort table]  
  
  
Additional factors added to each record from the Bulletin:  
  
**Split_Year**  FAO reporting, 1 July to 30 June, with year identified for June.  
  
**CC_Season**  CCAMLR Season, 1 December to 30 November, with year identified for November.  
  
```{r ,echo=FALSE}
# CEdata is the main data frame with effort records

CC_Season<-CEdata[,"Calendar_Year"]
NextYear<-!is.na(CEdata[,"Month"]) & CEdata[,"Month"]>11
CC_Season[NextYear]<-CC_Season[NextYear]+1
Split_Year<-CEdata[,"Calendar_Year"]
NextYear<-!is.na(CEdata[,"Month"]) & CEdata[,"Month"]>6
Split_Year[NextYear]<-Split_Year[NextYear]+1
CEdata<-cbind(CEdata,CC_Season,Split_Year)
```


```{r catch_1, echo=FALSE, eval=FALSE}
# separation of krill catch from fish catch given same effort record.  assume effort was bottom trawling if it was mixed as no data to differentiate.


########################################################################
# modify records to enable use of rules to assign catches to MEASO areas

# NOTE - IF RECORDS ARE MODIFIED TO CHANGE GROUP - MAKE CHANGES IN "B-M Step1.CSV" OR "B-M Step2.CSV" AS REQUIRED 

########
# Case 1: SUN catch in Area 58 in years 1978, 1979.  Has Antarctic krill and Subantarctic fish species. Reassign krill to 
# midwater trawl (not bottom trawl) and krill fishery rather than groundfish fishery

dfSelect <- (CEdata[,"Flag_CTY_Code"]=="SUN" 
          & CEdata[,"GAR_Code"]=="58" 
          & (CEdata[,"Calendar_Year"]=="1978" | CEdata[,"Calendar_Year"]=="1979")
          & CEdata[,"Catch_TXN_Code"]== "KRI")
CEdata[dfSelect,"Target_TXN_Code"] <- "KRI"  # for krill fishery


# Added records to "B-M Step2.csv"  :  
#            OT  SUN  7  58  1978  M
#            OT  SUN  7  58  1979  M

```

# Corrections of data in the Statistical Bulletin

Effort data for longline fishing in 1996 Split-Year from 58.5.1 seems an order of magnitude higher than plausible.  The mean number of hooks per haul for that year was 29,075 compared to a maximum mean for all other years of 9,319 hooks per line. Inspection of the monthly records, including consideration of flag state, the error seems to be for that split year irrespective of flag state.  Dividing by 10 brings the hooks in line with hauls and catches in years before and after that period for the flag states involved.

```{r Corrections, echo=FALSE}
dfSelect<-CEdata[,"GAR_Code"]=="5851" & ((CEdata[,"Calendar_Year"]==1995 & CEdata[,"Month"]>6) |(CEdata[,"Calendar_Year"]==1996 & CEdata[,"Month"]<7)) & CEdata[,"GTY_Code"]=="LLS"
print(CEdata[dfSelect,c("Flag_CTY_Code","Calendar_Year","Month","Target_TXN_Code","Vessel_Count","Haul_Count","Hook_Count")])
CEdata[dfSelect,"Hook_Count"]<-CEdata[dfSelect,"Hook_Count"]/10

```

# Summary of fisheries  
  
## Target Fisheries  
  
The development of Antarctic fisheries began in the 1960s with commercial quantities first being taken in 1969 by the Soviet Union. @RN6645 describes the histories of the fisheries.  He noted that the main target finfish species until publication of his book had been the bentho-pelagic Nototheniids - *Notothenia rossii*, *Lepidonothen squamifrons*, *Patagonotothen guntheri*, *Dissostichus eliginoides* - and the Channicthyds (icefish) - *Champsocephalus gunnari*, *Chaenodraco wilsoni* [which was often misreported as *C. gunnari*, @RN6645] -, and the pelagic myctophids, notably *Electrona carlsbergi*.  The other main target species at that time was Antarctic krill, *Euphausia superba*.  The only additional species to be targetted have been lithodid crabs and *D. mawsoni*.  Some exploratory fishing for the Antarctic silverfish, *PLeurogramma antarcticum*, and squid have been undertaken from time to time but these fisheries never became established.

Records are assigned in the Bulletin database to fisheries according to target species.  Some of the notothenids caught in the early trawl fisheries were grouped.  The different target species are further grouped to simply differentiate between different gears and deployment in the water column.  The groundfish fisheries had various assignments of target species and are grouped here as a 'groundfish' fishery.  The assignments are in the following table: 

```{r TargetGroups, echo=FALSE}

TargetFishery<-CSB_taxa[unique(match(CEdata[,"Target_TXN_Code"],CSB_taxa[,"TXN_Code"])),]
TF_Plot_Order<-data.frame(TFn      = c(     3,     2,     8,     1,     7,     6,      1,    2,     1 
                                            ,    6,     1,     5,     9,     1,     2)
                         ,TXN_Code = c( "TOT", "ANI", "SQS", "MZZ", "KRI", "LXX", "NOX", "ICX", "NOG"
                                            ,"ELC", "GHP", "ANS", "KCX", "NOS", "WIC")
                         ,DepthRange = c("600-1800m", "100-700m", "Pelagic", "-", "Pelagic", "Pelagic", "0-500m", "100-650", "0-500m"
                                            ,"Pelagic", "150-350m", "0-700m", "200-1500m", "0-600m", "100-650m")
                          ) # end data frame

TF_Plot_Order<-TF_Plot_Order[order(TF_Plot_Order[,"TFn"]),]

printTF<-data.frame(Fishery    = TF_Names[match(TF_Plot_Order[,"TFn"],TF_Names[,"TFn"]),"Fishery"]
                   ,TaxonCode  = TF_Plot_Order[,"TXN_Code"]
                   ,TaxonName  = CSB_taxa[match(TF_Plot_Order[,"TXN_Code"],CSB_taxa[,"TXN_Code"]),"TXN_Name"]
                   ,Depth      = TF_Plot_Order[,"DepthRange"]
                   ) # end df

# create vector to be added to CEdata for the Target fishery for each record

Fishery_type<-TF_Plot_Order[match(CEdata[,"Target_TXN_Code"],TF_Plot_Order[,"TXN_Code"]),"TFn"]  # plot by number of Target Fishery to get right order 

CEdata<-cbind(CEdata,Fishery_type)
dimnames(CEdata)[[2]][length(names(CEdata))]<-"TFN"
```


```{r,echo=FALSE}
kable(printTF,format="simple",align="l",row.names=NA,caption="Assignment of target taxa to Fisheries for summarising data.")
```
  
  
A new factor was added to the main data frame with details in a reference data frame:

**TFN**  Fishery number assigned to the record, as per the legend sequence in Figure \@ref(fig:TargetFisheries).



In the analysis of catch data, records were checked for their assignment to target fisheries based on the dominant species caught over the course of one year in that fishery, aggregated according to nominated gear types.  Records having patterns of aggregated catches that did not match the general pattern of dominant species caught were reassigned to other fisheries for which the pattern was more similar.  This only occurred for catches in the groundfish, mackerel icefish and krill fisheries in the 1970s prior to CCAMLR.

  
## Gear Type  
  
Gear types in the CCAMLR Statistical Bulletin have been specifically identified as bottom and midwater trawls, hooks and lines, pots and traps, squid jigging and seines.    
  
Fisheries in the 1970s and 1980s were undertaken primarily using otter trawls.  While these trawls became regularly differentiated between bottom and midwater trawling since that time, those early years had a large proportion of trawling not differentiated (i.e. Otter Trawl nei).  As they comprise a large component of the early fisheries, an assessment of the potential historical effects of fishing on the ecosystem needs to assign these trawls to either bottom or midwater fishing.  A two step process was used to assign Otter Trawls Nei to either of the categories.  
  
**Step 1**: Catches for individual taxa were aggregated using three factors - gear type, flag country, fishery.  They were initially aggregated with an additional factor, year, in order to exclude records for taxa with an annual catch less than 30 tonnes.  The data for taxa were then  aggregated across years within the combinations of the three main factors.  The pattern of relative abundance of taxa within the target fisheries and with gear type were used to check whether assignment to pelagic (midwater) or bottom fishing were likely to be correct.  For example, midwater fishing typically yielded large quantities of krill, myctophids and/or silverfish, the latter two rarely being seen in bottom trawls.  As a result of this checking, no trawls already assigned to midwater or bottom were changed.  For the unassigned otter trawls, the myctophid target fishery was assigned to midwater trawling.  The remainder were assigned to bottom trawling, except for the Groundfish and Krill target fisheries of the Soviet Union, which did not have clear catch patterns relating to either midwater or bottom fisheries (groundfish and krill were represented in equal measure).  These were further analysed in Step 2.  
  
  
```{r GTstep1,echo=FALSE}
# add location following inspection and creating a CSV file with relevant assignment from first step: data_Location_B_M_Step_1

dfTmp1<-merge(CEdata,data_Location_B_M_Step_1,by=c("GTY_Code","Flag_CTY_Code","TFN"))

```
  
**Step 2**:  The Soviet Union data for unassigned otter trawls were examined by the combination of three factors - target fishery (only groundfish and krill were represented), CCAMLR catch reporting areas, and year.  For the groundfish fishery, some combinations were dominated by krill with comparatively few groundfish represented.  These were assigned to midwater trawling, with the remainder assigned to bottom fishing.
  
```{r GTstep2,echo=FALSE}
# modify location following inspection of SUN data for OT and creating a CSV file with relevant assignment from second step: data_Location_B_M_Step_2

dfTmp2<-merge(dfTmp1,data_Location_B_M_Step_2,by=c("GTY_Code","Flag_CTY_Code","TFN","GAR_Code","Calendar_Year"),all.x=TRUE)
dfTmp2[dfTmp2[,"Location.x"]=="U","Location.x"]<-dfTmp2[dfTmp2[,"Location.x"]=="U","Location.y"]
dimnames(dfTmp2)[[2]][dimnames(dfTmp2)[[2]]=="Location.x"]<-"Location"
CEdata<-dfTmp2[,-which(dimnames(dfTmp2)[[2]] %in% "Location.y")]
GTY_rev<-CEdata[,"GTY_Code"]
GTY_rev[GTY_rev=="OT"]<-unlist(lapply(CEdata[GTY_rev=="OT","Location"],function(g){paste("OT",g,sep="")}))
CEdata<-cbind(CEdata,GTY_rev)

remove("dfTmp1")
remove("dfTmp2")
remove("GTY_rev")

```
  
A revised GTY code is added to the main data frame along with an assignment of all fisheries to a location in the water column in which the gear was deployed:  
  
**GTY_rev**    Revised GTY_Code to replace OT code  
**Location**   Gear deployed on or near to the bottom (B) or midwater (M).  


## Total Catch of bottom fisheries (target species)

The total catch of target species in bottom fisheries was calculated and added to the effort data in order to identify incomplete effort records.

```{r BottomTrawl_TotalCatch, echo=FALSE}
# deal with no effort data

# merge columns for each record which is the total groundfish+icefish+toothfish catch in order to analyse the 
# proportion of the catch in the year represented by the records with effort information.

CatchTaxa<-c("TOT","TOP","TOA",BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(1,2,10,15,16)),"Code"],BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(3,9)),"Code"])

# extract catch data associated with effort records & compare with a total extraction of target catch data

RecordID<-CEdata[,"AFE_ID"]

#subset catch data to include records from effort data and only for CatchTaxa

BottomTrawlCatch<-CSBdata[which(CSBdata[,"AFE_ID"] %in% RecordID),]
BottomTrawlCatch<-BottomTrawlCatch[which(BottomTrawlCatch[,"Catch_TXN_Code"] %in% CatchTaxa),]
BTcatch<-aggregate(BottomTrawlCatch[,"Green_Weight"],list(BottomTrawlCatch[,"AFE_ID"]),sum)
BTcatch
dimnames(BTcatch)[[2]]<-c("AFE_ID","Catch")
CEdata<-merge(CEdata,BTcatch,by="AFE_ID")
print(CEdata)


# check that all the catch is assigned to effort data
CatchWithEffortData<-aggregate(CEdata[,"Catch"],list(CEdata[,"Calendar_Year"]),sum)
dimnames(CatchWithEffortData)[[2]]<-c("Calendar_Year","Catch")

CatchInCSB<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),]
CatchInCSBdata<-aggregate(CatchInCSB[,"Green_Weight"],list(CatchInCSB[,"Calendar_Year"]),sum)
dimnames(CatchInCSBdata)[[2]]<-c("Calendar_Year","Catch")

plot(CatchWithEffortData[,"Calendar_Year"],CatchWithEffortData[,"Catch"],type="l")
lines(CatchInCSBdata[,"Calendar_Year"],CatchInCSBdata[,"Catch"],type="l",col="red")


```

# Rules for distributing effort between MEASO reporting areas

Effort was distributed amongst MEASO areas according to the rules developed for distributing catch.

```{r MEASOdistributionFunctions,echo=FALSE}




########## Seabed areas #############################################

Seabed_areas <- readRDS(Seabed_file)
# give each cell an area of 2x2 km until it is available in input file
Seabed_areas<-cbind(Seabed_areas,rep(4,nrow(Seabed_areas)))

# rename variables to be consistent with code
dimnames(Seabed_areas)[[2]]<-c("Lon","Lat","Cell","Depth","Iceshelf","MEASO","ASD","SSRU","SSMU","Area")

Cbed_rules<-Seabed_areas[!(Seabed_areas[,"Iceshelf"]) & !is.na(Seabed_areas[,"ASD"]) 
                         & !is.na(Seabed_areas[,"MEASO"]),c("Cell","Lon","Lat","Depth","MEASO","ASD","SSMU","SSRU","Area")]
Cbed_rules[is.na(Cbed_rules[,"SSRU"]),"SSRU"]<-"NA"
Cbed_rules[is.na(Cbed_rules[,"SSMU"]),"SSMU"]<-"NA"

remove(Seabed_areas)  # free up memory
```


# Effort by bottom trawling
  
Bottom gears included in the Bulletin are otter trawls, beam trawls, unidentified trawls, longlines and pots.  Beam trawls and unidentified trawls were used by Australia in research in 2003.  While less than 10 hours trawling, these were included with the otter trawls for simplicity.

Ideally, effort would be measured as area of the seabed trawled.  This is not available in the Bulletin.  The closest measure is the number of hours.  Converting this to area would require the speed of the vessel as well as the trawl width or spread of the ground gear.  For some purposes, it is also useful to have the spread of the doors in order to measure effects of the warps.  

The number of records with different combinations of effort (hours, days, hauls) are:

```{r BottomTrawl_QC_1, echo=FALSE}

dTrawl<-CEdata[CEdata[,"Location"]=="B" & !(CEdata[,"GTY_rev"]=="LLS" | CEdata[,"GTY_rev"]=="FPO"), ]

EffortRecords<-                   (!is.na(dTrawl[,"Fishing_Hours"]) &  is.na(dTrawl[,"Fishing_Days"]) &  is.na(dTrawl[,"Haul_Count"]))
EffortRecords<-cbind(EffortRecords,( is.na(dTrawl[,"Fishing_Hours"]) & !is.na(dTrawl[,"Fishing_Days"]) &  is.na(dTrawl[,"Haul_Count"])))
EffortRecords<-cbind(EffortRecords,( is.na(dTrawl[,"Fishing_Hours"]) &  is.na(dTrawl[,"Fishing_Days"]) & !is.na(dTrawl[,"Haul_Count"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dTrawl[,"Fishing_Hours"]) & !is.na(dTrawl[,"Fishing_Days"]) &  is.na(dTrawl[,"Haul_Count"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dTrawl[,"Fishing_Hours"]) &  is.na(dTrawl[,"Fishing_Days"]) & !is.na(dTrawl[,"Haul_Count"])))
EffortRecords<-cbind(EffortRecords,( is.na(dTrawl[,"Fishing_Hours"]) & !is.na(dTrawl[,"Fishing_Days"]) & !is.na(dTrawl[,"Haul_Count"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dTrawl[,"Fishing_Hours"]) & !is.na(dTrawl[,"Fishing_Days"]) & !is.na(dTrawl[,"Haul_Count"])))
# for all NAs
res<-seq(1,nrow(dTrawl),1)
for(c in 1:ncol(EffortRecords)) res<-res[!EffortRecords[res,c]]
EffortRecords<-cbind(EffortRecords,rep(FALSE,nrow(dTrawl)))
EffortRecords[res,ncol(EffortRecords)]<-TRUE


cat("Records for Hours               : ",sum(EffortRecords[,1]),"\n",sep="")
cat("Records for Days                : ",sum(EffortRecords[,2]),"\n",sep="")
cat("Records for Hauls               : ",sum(EffortRecords[,3]),"\n",sep="")
cat("Records for Hours & Days        : ",sum(EffortRecords[,4]),"\n",sep="")
cat("Records for Hours & Hauls       : ",sum(EffortRecords[,5]),"\n",sep="")
cat("Records for Days & Hauls        : ",sum(EffortRecords[,6]),"\n",sep="")
cat("Records for Hours & Days & Hauls: ",sum(EffortRecords[,7]),"\n",sep="")
cat("Records for NA in all three     : ",sum(EffortRecords[,8]),"\n",sep="")
cat("Records Total                   : ",nrow(dTrawl),"\n",sep="")


# save records with missing effort
#write.csv2(dTrawl[EffortRecords[,8],],"CSB_missing_effort.csv")

# 
```

Most records include hours, with many of these also having the number of days.  The number of hauls is not common in the early decades.  No records have only hauls.  Here, effort is standardised as the number of hours.  
Caution is needed in interpreting these plots as not all records report the number of vessels contributing to the tallies.  For some records, there does not seem to be consistency between hours, days and hauls, even when considering the number of vessels.  For this analysis, the number of hours in the records are accepted, though they may need checking in the future.



```{r BottomTrawl_QC_3, echo=FALSE}

res<-dTrawl[EffortRecords[,7],]
HaulMax<-ceiling(max(res[,"Haul_Count"])/100)*100
DayMax<-ceiling(max(res[,"Fishing_Days"])/100)*100
HourMax<-ceiling(max(res[,"Fishing_Hours"])/1000)*1000

plot(res[,"Fishing_Days"],res[,"Fishing_Hours"],type="p",xlim=c(0,DayMax),ylim=c(0,HourMax),xlab="Fishing Days",ylab="Fishing Hours")
plot(res[,"Fishing_Days"],res[,"Haul_Count"],type="p",xlim=c(0,DayMax),ylim=c(0,HaulMax),xlab="Fishing Days",ylab="Haul Count")
plot(res[,"Haul_Count"],res[,"Fishing_Hours"],type="p",xlim=c(0,300),ylim=c(0,600),xlab="Haul Count",ylab="Fishing Hours")


Hours_rev<-dTrawl[,"Fishing_Hours"]
```

For those records where only days were available, the number of hours was estimated from a two phase regression of hours from days.  The regression estimated that 8.10611 hours of fishing per day for periods less than 19.22000 days, after which it is 11.71201 hours fishing per day (r2=0.92).

```{r BottomTrawl_QC_4, echo=FALSE}

HoursReg<-line(dTrawl[,"Fishing_Days"],dTrawl[,"Fishing_Hours"])
rDays<-c(0,600)
rHours<-HoursReg[[2]][1]+HoursReg[[2]][2]*rDays
plot(dTrawl[,"Fishing_Days"],dTrawl[,"Fishing_Hours"],type="p",xlim=c(0,30),ylim=c(0,400))
lines(rDays,rHours)

fnNLMhours<-function(p,Hrs,Days){  # two phase regression going through zero
#    y1=0+p[1]*Days when Days<=p[2]
#    y=y1(p2)+p[3]* Days when Days>p[2]
    SS<-rep(0,length(Days))
    SS[Days<=p[2]]<-(p[1]*Days[Days<=p[2]]-Hrs[Days<=p[2]])^2
    yinflexion<-p[1]*p[2]
    SS[Days>p[2]]<-(yinflexion+p[3]*(Days[Days>p[2]]-p[2])-Hrs[Days>p[2]])^2
    
    return(sum(SS))
    }

Hours<-dTrawl[,"Fishing_Hours"]
Days <-dTrawl[,"Fishing_Days"]

p<-nlm(fnNLMhours,c(5,10,10),Hours[!is.na(Hours) & !is.na(Days)],Days[!is.na(Hours) & !is.na(Days)])

plotX<-c(0,p[[2]][2],600)
estHoursFromDays<-function(x,p){
  y<-x*0
  y[x<=p[2]]<-x[x<=p[2]]*p[1]
  y[x>p[2]]<-p[1]*p[2]+(x[x>p[2]]-p[2])*p[3]
return(y)  
}
plot(dTrawl[,"Fishing_Days"],dTrawl[,"Fishing_Hours"],type="p",xlim=c(0,400),ylim=c(0,6000),xlab="Fishing Days",ylab="Fishing Hours")
lines(plotX,estHoursFromDays(plotX,p[[2]]))

# parameters are 8.10611 hours per day prior to 19.22000 days, after which it is 11.71201 hours fishing per day.



Hours_rev[EffortRecords[,6]]<-estHoursFromDays(dTrawl[EffortRecords[,6],"Fishing_Days"],p[[2]])

dTrawl<-bind_cols(dTrawl,list(Hours_rev = Hours_rev))
head(dTrawl)

# check the catch is compatible with expectations for bottom fishing, i.e. little difference with total catch of target species in CSBdata

CatchInTrawldata<-aggregate(dTrawl[,"Catch"],list(dTrawl[,"Calendar_Year"]),sum)
dimnames(CatchInTrawldata)[[2]]<-c("Calendar_Year","Catch")

plot(CatchWithEffortData[,"Calendar_Year"],CatchWithEffortData[,"Catch"],type="l")
lines(CatchInTrawldata[,"Calendar_Year"],CatchInTrawldata[,"Catch"],type="l",col="red")

# the difference is the pelagic icefish fishery which began in the late 1970s.

```




# Bottom Trawl Effort

Bottom trawls were undertaken by the Groundfish, Icefish and Toothfish fisheries.  As they have different fishing depths, these are extracted separately using the rules and then combined.

## Toothfish  
  
```{r Effort_setup, echo=FALSE}
# general setup 

CheckCatch<-TRUE
DepVar<-"Hours_rev"  # dependent variable to be accumulated
PixelsTotal <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels for map of total effort
EffortTimeSeries<-NULL  # accumulation of effort for each fishery for later aggregating into a single time series
KeepVars<-c("Split_Year")

Resolution<-4 # km2  of pixels

removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)
```


```{r Toothfish_trawl, echo=FALSE}

TF<-3  # Target Fishery = toothfish  ### could be vector
DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

# to ensure toothfish catch is assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(3),"Minimum"]<- -300  # minimum depth
  DI[c(3),"Maximum"]<- -1000  # maximum depth
  
DistRules <- fnSetupCatchDistRules(  # apply rules given depths
   dTrawl
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# determine total effort by rules

EffortByRules<-lapply(seq(1,length(DistRules),1),function(c,CD,dCSB,tf,DV,CheckCatch){  # rule#, ruleList,dataset,target fishery
  subCSB<-dCSB[CD[[c]]$Subset,]
  Effort<-subCSB[which(subCSB[,"TFN"] %in% tf),DV]
  if(CheckCatch){
      Catch<-subCSB[which(subCSB[,"TFN"] %in% tf),"Catch"]
      return(data.frame(Effort           = sum(Effort[!is.na(Effort)])
                       ,CatchTotal       = sum(Catch)
                       ,CatchNotNAEffort = sum(Catch[!is.na(Effort)]) ))
      } else { # end if CheckCatch
       return(data.frame(Effort = sum(Effort[!is.na(Effort)])))
      } #end else
},DistRules,dTrawl,TF,DepVar,CheckCatch)

EffortByRules<-bind_rows(EffortByRules)

####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(DistRules),1)){ # too memory intensive to do lapply
  if(DistRules[[c]]$Area_km2!=0){
    Density   <- EffortByRules[c,"Effort"]/DistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[DistRules[[c]]$CbedAreaSubset] <- 
      Pixels[DistRules[[c]]$CbedAreaSubset] + 
      Density*Resolution  # in order that sum of pixels in an area gives the correct quantity  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,EffortByRules[c,"Effort"])
  }
} # end loop c

cat(cat("Total effort in Bulletin for fishery ("),cat(TF_Plot_Order[which(TF_Plot_Order[,"TFn"] %in% TF),"TXN_Code"],sep=", "),cat("): ", sum(EffortByRules[,"Effort"])),"\n",sep="")
cat("     Proportion of Catch with Effort Records: ",(sum(EffortByRules[,"CatchNotNAEffort"])/sum(EffortByRules[,"CatchTotal"])),"\n",sep="")

cat("Effort allocated to pixels: ",sum(Pixels),"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and effort not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Effort")))))
} else {
 cat("No areas had rules with zero area, and effort not allocated\n\n") 
}

# combine with other densities

PixelsTotal<-PixelsTotal+Pixels

#############################################
# Effort by MEASO area over time

Res<-bind_rows(lapply(seq(1,length(DistRules),1),fnDistributeDepVar,DistRules,dTrawl,TF,DepVar,KeepVars))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(dTrawl)) {cat("Only ",nrow(Res)/nrow(dTrawl)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

# add records to total
EffortTimeSeries<-bind_rows(EffortTimeSeries,Res)


```
  
```{r plotSOmap_toothfish,echo=FALSE,fig.cap="Total recorded effort of toothfish from 1970 to 2018 plotted against ocean depth (bottom left legend) as effort density (hours per square kilometer) on a log10 scale (the top right legend).  "}

# Plot toothfish trawl effort

#prepare catch/pixel for plotting

PixelsLog10<- Pixels/Resolution
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green1","green3","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 4
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
PlotToFile<-TRUE

if(PlotToFile) {
  tiff("Effort_toothfish_bottom_trawl_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}

SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Trawl Hours.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()



```
  
  
```{r plotTimeSeries_toothfish, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for toothfish (*Dissostichus* spp.) in each of the MEASO areas."}


plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries_Effort,Res,DepVar,CheckCatch))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

```

```{r,echo=FALSE}

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,DepVar]<1,DepVar]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,DepVar]),DepVar])
minCatch<-min(pdf[!is.na(pdf[,DepVar]),DepVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,DepVar], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Effort (hours)", title="Effort for toothfish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p


if(PlotToFile) ggsave("Effort_toothfish_bottom_trawl_TS.tiff",width=15,height=10,units="cm")

```

```{r,echo=FALSE}
# plot time series of catches indicating proportion of catch with effort
PlotVar<-"CatchTotal"
PointSize<-"PropCatchNotNA"

if(plotYlog | !includeZeroCatch) pdf[pdf[,PlotVar]<1,PlotVar]<-NA   

if(removeLastYear) pdf_l<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxY<-max(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])
minY<-min(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minY)),10^ceiling(log10(maxY)))
} else {
  YmaxVals<-fnYmax(maxY)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf_l$MEASO<-factor(pdf_l$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf_l$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf_l[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  }

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
               )#end theme
p<- p+ geom_line(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, lty = Area)), show.legend=TRUE)
p<- p+ geom_point(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, size=pdf_l[,PointSize])), show.legend=TRUE)
p<-p+scale_size(name = "Prop. with effort"
     #          ,breaks = 3
               ,limits = c(0,1)
               ,range = c(0.2,3)
               ) # end point scale

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for toothfish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_toothfish_bottom_trawl_Catch_TS.tiff",width=15,height=10,units="cm")

```
## Groundfish

```{r Groundfish_trawl, echo=FALSE}

TF<-1  # Target Fishery = groundfish  ### could be vector
DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

DistRules <- fnSetupCatchDistRules(  # apply rules given depths
   dTrawl
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# determine total effort by rules

EffortByRules<-lapply(seq(1,length(DistRules),1),function(c,CD,dCSB,tf,DV,CheckCatch){  # rule#, ruleList,dataset,target fishery
  subCSB<-dCSB[CD[[c]]$Subset,]
  Effort<-subCSB[which(subCSB[,"TFN"] %in% tf),DV]
  if(CheckCatch){
      Catch<-subCSB[which(subCSB[,"TFN"] %in% tf),"Catch"]
      return(data.frame(Effort           = sum(Effort[!is.na(Effort)])
                       ,CatchTotal       = sum(Catch)
                       ,CatchNotNAEffort = sum(Catch[!is.na(Effort)]) ))
      } else { # end if CheckCatch
       return(data.frame(Effort = sum(Effort[!is.na(Effort)])))
      } #end else
},DistRules,dTrawl,TF,DepVar,CheckCatch)

EffortByRules<-bind_rows(EffortByRules)

####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(DistRules),1)){ # too memory intensive to do lapply
  if(DistRules[[c]]$Area_km2!=0){
    Density   <- EffortByRules[c,"Effort"]/DistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[DistRules[[c]]$CbedAreaSubset] <- 
      Pixels[DistRules[[c]]$CbedAreaSubset] + 
      Density*Resolution  # in order that sum of pixels in an area gives the correct quantity  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,EffortByRules[c,"Effort"])
  }
} # end loop c

cat(cat("Total effort in Bulletin for fishery ("),cat(TF_Plot_Order[which(TF_Plot_Order[,"TFn"] %in% TF),"TXN_Code"],sep=", "),cat("): ", sum(EffortByRules[,"Effort"])),"\n",sep="")
cat("     Proportion of Catch with Effort Records: ",(sum(EffortByRules[,"CatchNotNAEffort"])/sum(EffortByRules[,"CatchTotal"])),"\n",sep="")

cat("Effort allocated to pixels: ",sum(Pixels),"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and effort not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Effort")))))
} else {
 cat("No areas had rules with zero area, and effort not allocated\n\n") 
}

# combine with other densities

PixelsTotal<-PixelsTotal+Pixels

#############################################
# Effort by MEASO area over time

Res<-bind_rows(lapply(seq(1,length(DistRules),1),fnDistributeDepVar,DistRules,dTrawl,TF,DepVar,KeepVars))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(dTrawl)) {cat("Only ",nrow(Res)/nrow(dTrawl)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

# add records to total
EffortTimeSeries<-bind_rows(EffortTimeSeries,Res)


```
  
```{r plotSOmap_groundfish,echo=FALSE,fig.cap="Total recorded effort of groundfish from 1970 to 2018 plotted against ocean depth (bottom left legend) as effort density (hours per square kilometer) on a log10 scale (the top right legend).  "}

# Plot groudnfish trawl effort

#prepare catch/pixel for plotting

PixelsLog10<- Pixels/Resolution
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green1","green3","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 4
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Effort_groundfish_bottom_trawl_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}

SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Trawl Hours.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)
if(PlotToFile) dev.off()


```
  
  
```{r plotTimeSeries_groundfish, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for groundfish in each of the MEASO areas."}


plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries_Effort,Res,DepVar,CheckCatch))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

```

```{r,echo=FALSE}

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,DepVar]<1,DepVar]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,DepVar]),DepVar])
minCatch<-min(pdf[!is.na(pdf[,DepVar]),DepVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,DepVar], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Effort (hours)", title="Effort for groundfish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_groundfish_bottom_trawl_TS.tiff",width=15,height=10,units="cm")


```

```{r,echo=FALSE}
# plot time series of catches indicating proportion of catch with effort
PlotVar<-"CatchTotal"
PointSize<-"PropCatchNotNA"

if(plotYlog | !includeZeroCatch) pdf[pdf[,PlotVar]<1,PlotVar]<-NA   

if(removeLastYear) pdf_l<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxY<-max(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])
minY<-min(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minY)),10^ceiling(log10(maxY)))
} else {
  YmaxVals<-fnYmax(maxY)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf_l$MEASO<-factor(pdf_l$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf_l$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf_l[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  }

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
               )#end theme
p<- p+ geom_line(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, lty = Area)), show.legend=TRUE)
p<- p+ geom_point(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, size=pdf_l[,PointSize])), show.legend=TRUE)
p<-p+scale_size(name = "Prop. with effort"
     #          ,breaks = 3
               ,limits = c(0,1)
               ,range = c(0.2,3)
               ) # end point scale

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for groundfish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_groundfish_bottom_trawl_Catch_TS.tiff",width=15,height=10,units="cm")

```

## Icefish


```{r Icefish_trawl, echo=FALSE}

TF<-2  # Target Fishery = groundfish  ### could be vector
DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

DistRules <- fnSetupCatchDistRules(  # apply rules given depths
   dTrawl
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# determine total effort by rules

EffortByRules<-lapply(seq(1,length(DistRules),1),function(c,CD,dCSB,tf,DV,CheckCatch){  # rule#, ruleList,dataset,target fishery
  subCSB<-dCSB[CD[[c]]$Subset,]
  Effort<-subCSB[which(subCSB[,"TFN"] %in% tf),DV]
  if(CheckCatch){
      Catch<-subCSB[which(subCSB[,"TFN"] %in% tf),"Catch"]
      return(data.frame(Effort           = sum(Effort[!is.na(Effort)])
                       ,CatchTotal       = sum(Catch)
                       ,CatchNotNAEffort = sum(Catch[!is.na(Effort)]) ))
      } else { # end if CheckCatch
       return(data.frame(Effort = sum(Effort[!is.na(Effort)])))
      } #end else
},DistRules,dTrawl,TF,DepVar,CheckCatch)

EffortByRules<-bind_rows(EffortByRules)

####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(DistRules),1)){ # too memory intensive to do lapply
  if(DistRules[[c]]$Area_km2!=0){
    Density   <- EffortByRules[c,"Effort"]/DistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[DistRules[[c]]$CbedAreaSubset] <- 
      Pixels[DistRules[[c]]$CbedAreaSubset] + 
      Density*Resolution  # in order that sum of pixels in an area gives the correct quantity  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,EffortByRules[c,"Effort"])
  }
} # end loop c

cat(cat("Total effort in Bulletin for fishery ("),cat(TF_Plot_Order[which(TF_Plot_Order[,"TFn"] %in% TF),"TXN_Code"],sep=", "),cat("): ", sum(EffortByRules[,"Effort"])),"\n",sep="")
cat("     Proportion of Catch with Effort Records: ",(sum(EffortByRules[,"CatchNotNAEffort"])/sum(EffortByRules[,"CatchTotal"])),"\n",sep="")

cat("Effort allocated to pixels: ",sum(Pixels),"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and effort not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Effort")))))
} else {
 cat("No areas had rules with zero area, and effort not allocated\n\n") 
}

# combine with other densities

PixelsTotal<-PixelsTotal+Pixels

#############################################
# Effort by MEASO area over time

Res<-bind_rows(lapply(seq(1,length(DistRules),1),fnDistributeDepVar,DistRules,dTrawl,TF,DepVar,KeepVars))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(dTrawl)) {cat("Only ",nrow(Res)/nrow(dTrawl)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

# add records to total
EffortTimeSeries<-bind_rows(EffortTimeSeries,Res)


```
  
```{r plotSOmap_icefish_trawl,echo=FALSE,fig.cap="Total recorded trawl effort for icefish from 1970 to 2018 plotted against ocean depth (bottom left legend) as effort density (hours per square kilometer) on a log10 scale (the top right legend).  "}


#prepare catch/pixel for plotting

PixelsLog10<- Pixels/Resolution
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green1","green3","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 5
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Effort_icefish_bottom_trawl_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}
SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Trawl Hours.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()


```
  
  
```{r plotTimeSeries_icefish, echo=FALSE, fig.cap="Time series of icefish trawl effort (hours) from bottom gear in each of the MEASO areas."}

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries_Effort,Res,DepVar,CheckCatch))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

```

```{r,echo=FALSE}

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,DepVar]<1,DepVar]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,DepVar]),DepVar])
minCatch<-min(pdf[!is.na(pdf[,DepVar]),DepVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,DepVar], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Effort (hours)", title="Effort for icefish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_icefish_bottom_trawl_TS.tiff",width=15,height=10,units="cm")


```

```{r,echo=FALSE}
# plot time series of catches indicating proportion of catch with effort
PlotVar<-"CatchTotal"
PointSize<-"PropCatchNotNA"

if(plotYlog | !includeZeroCatch) pdf[pdf[,PlotVar]<1,PlotVar]<-NA   

if(removeLastYear) pdf_l<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxY<-max(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])
minY<-min(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minY)),10^ceiling(log10(maxY)))
} else {
  YmaxVals<-fnYmax(maxY)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf_l$MEASO<-factor(pdf_l$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf_l$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf_l[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  }

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
               )#end theme
p<- p+ geom_line(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, lty = Area)), show.legend=TRUE)
p<- p+ geom_point(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, size=pdf_l[,PointSize])), show.legend=TRUE)
p<-p+scale_size(name = "Prop. with effort"
     #          ,breaks = 3
               ,limits = c(0,1)
               ,range = c(0.2,3)
               ) # end point scale

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for icefish (bottom trawl)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_icefish_bottom_trawl_Catch_TS.tiff",width=15,height=10,units="cm")

```



  
## Total Trawl Effort  
  
```{r plotSOmap_total_trawl,echo=FALSE,fig.cap="Total recorded trawl effort from 1970 to 2018 plotted against ocean depth (bottom left legend) as effort density (hours per square kilometer) on a log10 scale (the top right legend).  "}

# Plot total trawl effort
Pixels<-PixelsTotal

#prepare catch/pixel for plotting

PixelsLog10<- Pixels/Resolution
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green1","green3","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 5
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Effort_total_bottom_trawl_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}

SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Trawl Hours.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()


```
  
  
```{r plotTimeSeries_totalTrawl, echo=FALSE, fig.cap="Time series of trawl effort (hours) from bottom gear in each of the MEASO areas."}
Res<-  EffortTimeSeries

plotYlog<-TRUE

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries_Effort,Res,DepVar,CheckCatch))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,DepVar]<1,DepVar]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,DepVar]),DepVar])
minCatch<-min(pdf[!is.na(pdf[,DepVar]),DepVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,DepVar], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Effort (hours)", title="Total Bottom Trawl Effort (hours)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p


if(PlotToFile) ggsave("Effort_total_bottom_trawl_TS.tiff",width=15,height=10,units="cm")

```

```{r,echo=FALSE}
# plot time series of catches indicating proportion of catch with effort
PlotVar<-"CatchTotal"
PointSize<-"PropCatchNotNA"

if(plotYlog | !includeZeroCatch) pdf[pdf[,PlotVar]<1,PlotVar]<-NA   

if(removeLastYear) pdf_l<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxY<-max(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])
minY<-min(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minY)),10^ceiling(log10(maxY)))
} else {
  YmaxVals<-fnYmax(maxY)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf_l$MEASO<-factor(pdf_l$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf_l$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf_l[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  }

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
               )#end theme
p<- p+ geom_line(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, lty = Area)), show.legend=TRUE)
p<- p+ geom_point(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, size=pdf_l[,PointSize])), show.legend=TRUE)
p<-p+scale_size(name = "Prop. with effort"
     #          ,breaks = 3
               ,limits = c(0,1)
               ,range = c(0.2,3)
               ) # end point scale

p <- p + labs(x = "Year", y ="Total Catch (tonnes)", title="Catch of target species using bottom trawls")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Effort_total_bottom_trawl_Catch_TS.tiff",width=15,height=10,units="cm")

```

# Longlining and Potting Effort

Longlining and potting is combined.  as they both use bottom longline deployments.  the two methods of longline fishing have not been differentiated - Spanish longlines, which tend to float off the bottom once deployed, and integrated weighted lines, which sit on the bottom.

## Longlines

```{r , echo=FALSE}

dLine<-CEdata[CEdata[,"Location"]=="B" & (CEdata[,"GTY_rev"]=="LLS"), ]

EffortRecords<-                    (!is.na(dLine[,"Hook_Count"]) &  is.na(dLine[,"Haul_Count"]) &  is.na(dLine[,"Fishing_Days"]))
EffortRecords<-cbind(EffortRecords,( is.na(dLine[,"Hook_Count"]) & !is.na(dLine[,"Haul_Count"]) &  is.na(dLine[,"Fishing_Days"])))
EffortRecords<-cbind(EffortRecords,( is.na(dLine[,"Hook_Count"]) &  is.na(dLine[,"Haul_Count"]) & !is.na(dLine[,"Fishing_Days"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dLine[,"Hook_Count"]) & !is.na(dLine[,"Haul_Count"]) &  is.na(dLine[,"Fishing_Days"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dLine[,"Hook_Count"]) &  is.na(dLine[,"Haul_Count"]) & !is.na(dLine[,"Fishing_Days"])))
EffortRecords<-cbind(EffortRecords,( is.na(dLine[,"Hook_Count"]) & !is.na(dLine[,"Haul_Count"]) & !is.na(dLine[,"Fishing_Days"])))
EffortRecords<-cbind(EffortRecords,(!is.na(dLine[,"Hook_Count"]) & !is.na(dLine[,"Haul_Count"]) & !is.na(dLine[,"Fishing_Days"])))
# for all NAs
res<-seq(1,nrow(dLine),1)
for(c in 1:ncol(EffortRecords)) res<-res[!EffortRecords[res,c]]
EffortRecords<-cbind(EffortRecords,rep(FALSE,nrow(dLine)))
EffortRecords[res,ncol(EffortRecords)]<-TRUE


cat("Records for Hooks                : ",sum(EffortRecords[,1]),"\n",sep="")
cat("Records for Hauls                : ",sum(EffortRecords[,2]),"\n",sep="")
cat("Records for Days                 : ",sum(EffortRecords[,3]),"\n",sep="")
cat("Records for Hooks & Hauls        : ",sum(EffortRecords[,4]),"\n",sep="")
cat("Records for Hooks & Days         : ",sum(EffortRecords[,5]),"\n",sep="")
cat("Records for Hauls & Days         : ",sum(EffortRecords[,6]),"\n",sep="")
cat("Records for Hooks, Hauls, Days   : ",sum(EffortRecords[,7]),"\n",sep="")
cat("Records for NA in all three      : ",sum(EffortRecords[,8]),"\n",sep="")
cat("Records Total                    : ",nrow(dLine),"\n",sep="")


# save records with missing effort
#write.csv2(dLine[EffortRecords[,8],],"CSB_missing_effort.csv")

# 
```

Number of hooks is a good proxy for the length of the longline.  This is because they are typically set 1m apart.  Less than 5% of longline records (114 out of 2603) do not have hooks associated with them.  These records were not used in this analysis.


```{r , echo=FALSE}
# general setup 

CheckCatch<-TRUE
DepVar<-"Hook_Count"  # dependent variable to be accumulated
PixelsTotal <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels for map of total effort
EffortTimeSeries<-NULL  # accumulation of effort for each fishery for later aggregating into a single time series
KeepVars<-c("Split_Year")

Resolution<-4 # km2  of pixels

removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)
```


```{r Toothfish_LL, echo=FALSE}

TF<-3  # Target Fishery = toothfish  ### could be vector
DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

DistRules <- fnSetupCatchDistRules(  # apply rules given depths
   dLine
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# determine total effort by rules

EffortByRules<-lapply(seq(1,length(DistRules),1),function(c,CD,dCSB,tf,DV,CheckCatch){  # rule#, ruleList,dataset,target fishery
  subCSB<-dCSB[CD[[c]]$Subset,]
  Effort<-subCSB[which(subCSB[,"TFN"] %in% tf),DV]
  if(CheckCatch){
      Catch<-subCSB[which(subCSB[,"TFN"] %in% tf),"Catch"]
      return(data.frame(Effort           = sum(Effort[!is.na(Effort)])
                       ,CatchTotal       = sum(Catch)
                       ,CatchNotNAEffort = sum(Catch[!is.na(Effort)]) ))
      } else { # end if CheckCatch
       return(data.frame(Effort = sum(Effort[!is.na(Effort)])))
      } #end else
},DistRules,dLine,TF,DepVar,CheckCatch)

EffortByRules<-bind_rows(EffortByRules)

####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(DistRules),1)){ # too memory intensive to do lapply
  if(DistRules[[c]]$Area_km2!=0){
    Density   <- EffortByRules[c,"Effort"]/DistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[DistRules[[c]]$CbedAreaSubset] <- 
      Pixels[DistRules[[c]]$CbedAreaSubset] + 
      Density*Resolution  # in order that sum of pixels in an area gives the correct quantity  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,EffortByRules[c,"Effort"])
  }
} # end loop c

cat(cat("Total effort in Bulletin for fishery ("),cat(TF_Plot_Order[which(TF_Plot_Order[,"TFn"] %in% TF),"TXN_Code"],sep=", "),cat("): ", sum(EffortByRules[,"Effort"])),"\n",sep="")
cat("     Proportion of Catch with Effort Records: ",(sum(EffortByRules[,"CatchNotNAEffort"])/sum(EffortByRules[,"CatchTotal"])),"\n",sep="")

cat("Effort allocated to pixels: ",sum(Pixels),"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and effort not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Effort")))))
} else {
 cat("No areas had rules with zero area, and effort not allocated\n\n") 
}

# combine with other densities

PixelsTotal<-PixelsTotal+Pixels

#############################################
# Effort by MEASO area over time

Res<-bind_rows(lapply(seq(1,length(DistRules),1),fnDistributeDepVar,DistRules,dLine,TF,DepVar,KeepVars))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(dLine)) {cat("Only ",nrow(Res)/nrow(dLine)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

# add records to total
EffortTimeSeries<-bind_rows(EffortTimeSeries,Res)


```
  
```{r plotSOmap_toothfishLL,echo=FALSE,fig.cap="Total recorded effort (hooks) of toothfish from 1970 to 2018 plotted against ocean depth (bottom left legend) as effort density (hooks per square kilometer) on a log10 scale (the top right legend).  "}

# Plot toothfish trawl effort

#prepare catch/pixel for plotting

PixelsLog10<- Pixels/Resolution  # make the measure per km2
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green1","green3","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 4
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Effort_longline_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}

SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Hooks.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()


```
  
  
```{r plotTimeSeries_toothfishLL, echo=FALSE, fig.cap="Time series of catches (tonnes) from longlining for toothfish (*Dissostichus* spp.) in each of the MEASO areas."}


plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries_Effort,Res,DepVar,CheckCatch))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

```

```{r,echo=FALSE}

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,DepVar]<1,DepVar]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,DepVar]),DepVar])
minCatch<-min(pdf[!is.na(pdf[,DepVar]),DepVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,DepVar], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Effort (hooks)", title="Effort for toothfish (longline)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p


if(PlotToFile) ggsave("Effort_longline_TS.tiff",width=15,height=10,units="cm")

```

```{r,echo=FALSE}
# plot time series of catches indicating proportion of catch with effort
PlotVar<-"CatchTotal"
PointSize<-"PropCatchNotNA"

if(plotYlog | !includeZeroCatch) pdf[pdf[,PlotVar]<1,PlotVar]<-NA   

if(removeLastYear) pdf_l<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxY<-max(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])
minY<-min(pdf_l[!is.na(pdf_l[,PlotVar]),PlotVar])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minY)),10^ceiling(log10(maxY)))
} else {
  YmaxVals<-fnYmax(maxY)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf_l$MEASO<-factor(pdf_l$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf_l$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf_l[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  }

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
               )#end theme
p<- p+ geom_line(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, lty = Area)), show.legend=TRUE)
p<- p+ geom_point(pdf_l, mapping = (aes(x = pdf_l[,"Split_Year"], y = pdf_l[,PlotVar], col = Area, size=pdf_l[,PointSize])), show.legend=TRUE)
p<-p+scale_size(name = "Prop. with effort"
     #          ,breaks = 3
               ,limits = c(0,1)
               ,range = c(0.2,3)
               ) # end point scale

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for toothfish (longline)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p
if(PlotToFile) ggsave("Effort_longline_Catch_TS.tiff",width=15,height=11,units="cm")

```

# References    
.     
