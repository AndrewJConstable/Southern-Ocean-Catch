---
title: "MEASO fishery statistics"
author: "Andrew Constable"
date: "16/09/2020"
output: 
  bookdown::html_document2:
    toc: true
    toc_depth: 4
    fig_caption: yes
bibliography: '/Users/andreworca/Desktop/_wAAD/_r/Southern-Ocean-Catch/CatchRefs.bibtex'   

---

```{r setup, include=FALSE}
library(knitr)
library(ggplot2)
library(scales)
library(png) # for grabbing dimensions of png files
library(dplyr)
library(raster)
library(rgdal)
library(maptools)
library(sp)
library(measoshapes) # from GitHub  remotes::install_github("AustralianAntarcticDivision/measoshapes")
library(sf)
library(RColorBrewer)
library(SOmap)  #remotes::install_github("AustralianAntarcticDivision/SOmap")
library(geodist)
library(rgeos)
library(colorspace)


knitr::opts_chunk$set(echo = TRUE)


#RootDir<-'/Users/andreworca/Desktop/_wAAD/'
#WorkDir<-'/Users/andreworca/Desktop/_wAAD/_d/Catch/'

RootDir<-'/Volumes/iMaWizard/'
WorkDir<-'/Volumes/iMaWizard/_w/_d/Catch/'

# Editing and Development Notes:
#
# 1. This code is inherited from "MEASO CCAMLR catch data.rmd" which has the basic analyses testing the data.  
            # The code here strips away the testing routines.
#


source("InputData.R")

# Output flags

printMaps<-TRUE
plotCatchMaps <- TRUE
plotToothfish<-TRUE
addIUU<-TRUE

PlotToFile<-TRUE

SOmapTrimLat<--40
SOmapFixBreaks<-TRUE

# distribution of catches by which areas

AreaGroups<-c("MEASO")  # add ASD if need both


# decades for reporting

decade<-seq(1960,2010,10)



################# load functions #####################

source("fnBaseRules.R") # the rules for dividing ASD catch and effort between MEASO areas
source("fnCatch_summary.R")
source("fnDepthArea.R")
source("fnCalcMEASO_TimeSeries.R")
source("fnSetupCatchDistRule.R")
source("fnCatchDistRule.R")
source("fnPropInMareaForRule.R")


fnYmax<-function(m){# m is the maximum catch
  om<-floor(log10(m)) # order of magnitude
 if((m*10^(-om))>5) cInt<-10^om else cInt<-0.5*10^om
 return(c(ceiling(m/cInt)*cInt,cInt))
  } # end function



```

# Introduction  
  
MEASO has a number of chapters that refer to, or detail, the nature and scale of fisheries over time.  The aim of this vignette is to describe the history of fisheries in the Southern Ocean and how that history varies between MEASO areas.  Section 2 details finfish and krill fisheries in the Southern Ocean.  Sections 3 and 4 detail catches of whales and seals respectively.  Incidental mortality of seabirds is considered separately to Southern Ocean fisheries because of the mortality of Southern Ocean seabirds throughout the Southern Hemisphere. This is documented in Section 5.  
   
# Finfish and krill fisheries   
  
CCAMLR provides the main source of information on finfish and krill fisheries through various reports & publications (www.ccamlr.org), although other sources are useful for clarifying the locations and scale of catches prior to the establishment of CCAMLR in 1980 [e.g. @RN49] and for the scale of incidental mortality of Southern Ocean seabirds in longline fisheries in the Southern Hemisphere (www.acap.aq).  
  
Here I use catch and effort data available in the CCAMLR Statistical Bulletin (https://www.ccamlr.org/en/publications/statistical-bulletin) as the primary source of data (hereafter referred to as CSB data or Bulletin data). 

After securing permission from data owners, the CCAMLR Secretariat extracted catch and effort data by MEASO areas. These data were originally  submitted as haul data, with geolocation of catches.  However, the dataset as a whole is not inclusive of all data in the Statistical Bulletin.  They are used to help partition the data in the Statistical Bulletin as appropriate. Hereafter, they are referred to as Haul Data.
  
The reason for the discrepancy is that early data were not required to be submitted with haul information and, instead, were simply summaries of catch and effort by CCAMLR reporting areas - Statistical Areas, Subareas or Divisions (hereafter referred to ASD areas). The scale of aggregation of submitted data varied between reporting nation.  Even since the requirement for reporting by haul, there remains discrepancies between the aggregated Bulletin Data and aggregated Haul Data.  These discrepancies are reported here.
  
The attributes of the Bulletin dataset and the relationship between the ASD areas and the MEASO areas are provided in the first subsection.  The second subsection summarises the overall attributes of the fisheries in the CCAMLR area.  The third subsection describes how the Bulletin data were subdivided into MEASO areas.  This section describes the haul dataset and its differences with the Bulletin dataset.  The fourth subsection then summarises the attributes of the fisheries relevant for considering the effects of fishing on Southern Ocean ecosystems.
  
  
## CCAMLR Statistical Bulletin  
  
The CCAMLR Statistical Bulletin 2019 contains catch and effort records for fisheries up to the 2017-2018 split year. It comprised separate catch and effort files, along with files containing data on each of the factors.    
    
Each of the variables in the CCAMLR Statistical Bulletin (CSB) tables are described here along with a printout of the levels in each.

**AFC_ID**  Unique identifier for AGGREGATED FISHERY CATCH (system generated)[this identifier is in catch table but not included in the effort table]  

**AFE_ID** Unique identifier for the related record in AGGREGATED FISHERY EFFORT (system generated)[this identifier is in both catch data and effort data and used to link the two tables] 

**Flag_CTY_Code**  ISO 3 code for the flag of the fishing vessel(s).[in both catch and effort tables]  

**Calendar_Year**  Calendar year (YYYY) when fishing occurred.[in both catch and effort tables]  

**Month**  Month (MM) when fishing occurred.[in both catch and effort tables]  

**GAR_Code**  Geographic area code for the statistical area, subarea or division where fishing occurred. [in both catch and effort tables]  

**Target_TXN_Code**  3 alpha code for target taxon.[in both catch and effort tables]  

**GTY_Code**  Code for the gear used during fishing.[in both catch and effort tables]  

**FAC_Code**  Code for the fishing activity.[in both catch and effort tables]  

**VSZ_Code**  Code for the size category of fishing vessels based on gross tonnage.[in both catch and effort tables]  

**Catch_TXN_Code**  3 alpha code for each taxon caught.[only in catch table]  

**Green_Weight**  Green weight (tonne) of the catch.[only in catch table]  

**Fishing_Hours**  Total number of hours of fishing.[only in effort table]  

**Fishing_Days**  Total number of days during which fishing occurred.[only in effort table]  

**Vessel_Count**  Total number of vessels fishing.[only in effort table]  

**Haul_Count**  Total number of hauls made during fishing.[only in effort table]  

**Hook_Count**  Total number of hooks set. Applies to longline fishing only.[only in effort table]  

**Pot_Count**  Total number of pots set. Applies to pot fishing only.[only in effort table]  
  
  
Additional factors added to each record from the Bulletin:  
  
**Split_Year**  FAO reporting, 1 July to 30 June, with year identified for June.  
  
**CC_Season**  CCAMLR Season, 1 December to 30 November, with year identified for November.  
  
```{r ,echo=FALSE}
# CSBdata is the main data frame with catch records

CC_Season<-CSBdata[,"Calendar_Year"]
NextYear<-!is.na(CSBdata[,"Month"]) & CSBdata[,"Month"]>11
CC_Season[NextYear]<-CC_Season[NextYear]+1
Split_Year<-CSBdata[,"Calendar_Year"]
NextYear<-!is.na(CSBdata[,"Month"]) & CSBdata[,"Month"]>6
Split_Year[NextYear]<-Split_Year[NextYear]+1
CSBdata<-cbind(CSBdata,CC_Season,Split_Year)


########################################################################
# modify records to enable use of rules to assign catches to MEASO areas

# NOTE - IF RECORDS ARE MODIFIED TO CHANGE GROUP - MAKE CHANGES IN "B-M Step1.CSV" OR "B-M Step2.CSV" AS REQUIRED 

########
# Case 1: SUN catch in Area 58 in years 1978, 1979.  Has Antarctic krill and Subantarctic fish species. Reassign krill to 
# midwater trawl (not bottom trawl) and krill fishery rather than groundfish fishery

dfSelect <- (CSBdata[,"Flag_CTY_Code"]=="SUN" 
          & CSBdata[,"GAR_Code"]=="58" 
          & (CSBdata[,"Calendar_Year"]=="1978" | CSBdata[,"Calendar_Year"]=="1979")
          & CSBdata[,"Catch_TXN_Code"]== "KRI")
CSBdata[dfSelect,"Target_TXN_Code"] <- "KRI"  # for krill fishery


# Added records to "B-M Step2.csv"  :  
#            OT  SUN  7  58  1978  M
#            OT  SUN  7  58  1979  M

```


## Summary of fisheries  
  
### Target Fisheries  
  
The development of Antarctic fisheries began in the 1960s with commercial quantities first being taken in 1969 by the Soviet Union. @RN6645 describes the histories of the fisheries.  He noted that the main target finfish species until publication of his book had been the bentho-pelagic Nototheniids - *Notothenia rossii*, *Lepidonothen squamifrons*, *Patagonotothen guntheri*, *Dissostichus eliginoides* - and the Channicthyds (icefish) - *Champsocephalus gunnari*, *Chaenodraco wilsoni* [which was often misreported as *C. gunnari*, @RN6645] -, and the pelagic myctophids, notably *Electrona carlsbergi*.  The other main target species at that time was Antarctic krill, *Euphausia superba*.  The only additional species to be targetted have been lithodid crabs and *D. mawsoni*.  Some exploratory fishing for the Antarctic silverfish, *PLeurogramma antarcticum*, and squid have been undertaken from time to time but these fisheries never became established.

Records are assigned in the Bulletin database to fisheries according to target species.  Some of the notothenids caught in the early trawl fisheries were grouped.  The different target species are further grouped to simply differentiate between different gears and deployment in the water column.  The groundfish fisheries had various assignments of target species and are grouped here as a 'groundfish' fishery.  The assignments are in the following table: 

```{r TargetGroups, echo=FALSE}

TargetFishery<-CSB_taxa[unique(match(CSBdata[,"Target_TXN_Code"],CSB_taxa[,"TXN_Code"])),]
TF_Plot_Order<-data.frame(TFn      = c(     3,     2,     8,     1,     7,     6,      1,    2,     1 
                                            ,    6,     1,     5,     9,     1,     2)
                         ,TXN_Code = c( "TOT", "ANI", "SQS", "MZZ", "KRI", "LXX", "NOX", "ICX", "NOG"
                                            ,"ELC", "GHP", "ANS", "KCX", "NOS", "WIC")
                         ,DepthRange = c("600-1800m", "100-700m", "Pelagic", "-", "Pelagic", "Pelagic", "0-500m", "100-650", "0-500m"
                                            ,"Pelagic", "150-350m", "0-700m", "200-1500m", "0-600m", "100-650m")
                          ) # end data frame
TF_Plot_Order<-TF_Plot_Order[order(TF_Plot_Order[,"TFn"]),]

printTF<-data.frame(Fishery    = TF_Names[match(TF_Plot_Order[,"TFn"],TF_Names[,"TFn"]),"Fishery"]
                   ,TaxonCode  = TF_Plot_Order[,"TXN_Code"]
                   ,TaxonName  = CSB_taxa[match(TF_Plot_Order[,"TXN_Code"],CSB_taxa[,"TXN_Code"]),"TXN_Name"]
                   ,Depth      = TF_Plot_Order[,"DepthRange"]
                   ) # end df

# create vector to be added to CSBdata for the Target fishery for each record

Fishery_type<-TF_Plot_Order[match(CSBdata[,"Target_TXN_Code"],TF_Plot_Order[,"TXN_Code"]),"TFn"]  # plot by number of Target Fishery to get right order 

CSBdata<-cbind(CSBdata,Fishery_type)
dimnames(CSBdata)[[2]][length(names(CSBdata))]<-"TFN"
```


```{r,echo=FALSE}
kable(printTF,format="simple",align="l",row.names=NA,caption="Assignment of target taxa to Fisheries for summarising data.")
```
  
  
A new factor was added to the main data frame with details in a reference data frame:

**TFN**  Fishery number assigned to the record, as per the legend sequence in Figure \@ref(fig:TargetFisheries).

Records were checked for their assignment to target fisheries based on the dominant species caught over the course of one year in that fishery, aggregated according to nominated gear types.  Records having patterns of aggregated catches that did not match the general pattern of dominant species caught were reassigned to other fisheries for which the pattern was more similar.  This only occurred for catches in the groundfish, mackerel icefish and krill fisheries in the 1970s prior to CCAMLR.

  
```{r TargetFisheries, out.width="70%", fig.cap="*Total catch (tonnes, all taxa) in each major fishery in the CCAMLR area in each decade from the 1960s to the present, derived from the CCAMLR Statistical Bulletin 2019*", fig.show='hold', fig.align='center', echo=FALSE}

# add zeros for each Fishery*Decade 

decade<-seq(1960,2010,10)
TFzeros<-do.call(rbind,lapply(seq(1,length(decade),1),function(t,decade,TFn){return(data.frame(Decade=rep(decade[t],length(TFn))
                                                                                              ,Fishery=TFn
                                                                                              ,Tonnes=rep(0,length(TFn))
                                                                                              ))},decade,TF_Names[,"TFn"]))

res1<-data.frame(Decade=10*(floor(CSBdata[,"Calendar_Year"]/10))
                ,Fishery=CSBdata[,"TFN"]
                ,Tonnes = CSBdata[,"Green_Weight"])
res1<-rbind(res1,TFzeros)

# add IUU catch if wanted

if(addIUU){
  res1_IUU<-data.frame(Decade=10*(floor(Toothfish_IUU[,"Year"]/10))
                      ,Fishery=rep(4,nrow(Toothfish_IUU))
                      ,Tonnes = Toothfish_IUU[,"Catch"])
  res1<-bind_rows(res1,res1_IUU)
   }

res<-as.data.frame(aggregate(res1[,"Tonnes"],list(res1[,"Decade"],res1[,"Fishery"]),sum))
dimnames(res)[[2]]<-c("Decade","Fishery","Tonnes")

plotYlog<-TRUE

if(plotYlog){
  res[res[,"Tonnes"]<1,"Tonnes"]<-1
   }

p <- ggplot()
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid"))

p<- p+ geom_col(res, mapping = (aes(x = factor(res[,"Decade"]), y = res[,"Tonnes"], fill = factor(res[,"Fishery"]))),position = position_dodge(preserve = 'single'))
p <- p + labs(x = "Decade", y ="Tonnes", fill = "Fishery",title="Total catch by decade for type of fishery")
if (plotYlog) p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = c(1E0,1E8)) + annotation_logticks(sides="l")
p <- p + scale_fill_discrete(name = "Fishery", breaks=levels(factor(res[,"Fishery"])),labels = TF_Names[as.character(TF_Names[,"TFn"])  %in%  levels(factor(res[,"Fishery"])),"Fishery"],type=TF_Names[,"Colour"]) # change legend labels

p

if(PlotToFile) ggsave("Catch_Fishery_Decade.tiff",width=15,height=10,units="cm")

```
  
### Gear Type  
  
Gear types in the CCAMLR Statistical Bulletin have been specifically identified as bottom and midwater trawls, hooks and lines, pots and traps, squid jigging and seines.    

```{r GearTypeSetup, echo=FALSE}

plotGearTypeRaw<-FALSE
plotGearTypeRev<-TRUE
# add zeros for each Fishery*Decade 
GTzeros<-do.call(rbind,lapply(seq(1,length(decade),1),function(t,decade,GT){return(data.frame(Decade=rep(decade[t],length(GT))
                                                                                              ,Gear=GT
                                                                                              ,Tonnes=rep(0,length(GT))
                                                                                              ))},decade,GT_Names[,"GTn"]))

```

  
```{r plotGearTypeRaw, out.width="70%", fig.cap="*Total catch (tonnes, all taxa) for each major gear type in the CCAMLR area in each decade from the 1960s to the present, derived from the CCAMLR Statistical Bulletin 2019*", fig.show='hold', fig.align='center', echo=FALSE}

if(plotGearTypeRaw){
res1<-data.frame(Decade=10*(floor(CSBdata[,"Calendar_Year"]/10))
                ,Gear=GT_Names[match(CSBdata[,"GTY_Code"],GT_Names[,"Gear"]),"GTn"]
                ,Tonnes = CSBdata[,"Green_Weight"])
res1<-rbind(res1,GTzeros)
res<-as.data.frame(aggregate(res1[,"Tonnes"],list(res1[,"Decade"],res1[,"Gear"]),sum))
dimnames(res)[[2]]<-c("Decade","Gear","Tonnes")

# exclude data
GTY_exclude<- GT_Names[match(c("TX","TBB"),GT_Names[,"Gear"]),"GTn"]     
res<-res[!(res[,"Gear"] %in% GTY_exclude),]
pGT_Names<- GT_Names[-(match(GTY_exclude,GT_Names[,"GTn"])),] 

plotYlog<-TRUE

if(plotYlog){
  res[res[,"Tonnes"]<1,"Tonnes"]<-1
   }

p <- ggplot()
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid"))

p<- p+ geom_col(res, mapping = (aes(x = factor(res[,"Decade"]), y = res[,"Tonnes"], fill = factor(res[,"Gear"]))),position = position_dodge(preserve = 'single'))
p <- p + labs(x = "Decade", y ="Tonnes", fill = "Gear",title="Total catch by decade for gear type")
if (plotYlog) p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = c(1E0,1E8)) + annotation_logticks(sides="l")
p <- p + scale_fill_discrete(name = "Gear", breaks=levels(factor(res[,"Gear"]))
                             ,labels = CRfishingGear[match(pGT_Names[
                                            match(as.character(pGT_Names[,"GTn"]),levels(factor(res[,"Gear"])))
                                            ,"Gear"],CRfishingGear[,"GTY_Code"]),"GTY_Name"]
                             ,type=pGT_Names[,"Colour"]) # change legend labels

p
} # end if plotGearTypeRaw

```
  
Fisheries in the 1970s and 1980s were undertaken primarily using otter trawls.  While these trawls became regularly differentiated between bottom and midwater trawling since that time, those early years had a large proportion of trawling not differentiated (i.e. Otter Trawl nei).  As they comprise a large component of the early fisheries, an assessment of the potential historical effects of fishing on the ecosystem needs to assign these trawls to either bottom or midwater fishing.  A two step process was used to assign Otter Trawls Nei to either of the categories.

**Step 1**: Catches for individual taxa were aggregated using three factors - gear type, flag country, fishery.  They were initially aggregated with an additional factor, year, in order to exclude records for taxa with an annual catch less than 30 tonnes.  The data for taxa were then  aggregated across years within the combinations of the three main factors.  The pattern of relative abundance of taxa within the target fisheries and with gear type were used to check whether assignment to pelagic (midwater) or bottom fishing were likely to be correct.  For example, midwater fishing typically yielded large quantities of krill, myctophids and/or silverfish, the latter two rarely being seen in bottom trawls.  As a result of this checking, no trawls already assigned to midwater or bottom were changed.  For the unassigned otter trawls, the myctophid target fishery was assigned to midwater trawling.  The remainder were asigned to bottom trawling, except for the Groundfish and Krill target fisheries of the Soviet Union, which did not have clear catch patterns relating to either midwater or bottom fisheries (groundfish and krill were represented in equal measure).  These were further analysed in Step 2.  
  
  
```{r GTstep1,echo=FALSE}
# visual inspection of aggregation according to th

# code to check assignment of location of fishing gear - bottom or midwater fisheries - once done, this code can be turned off with logical

                      CheckBottomFishAssignments<-FALSE
                      if(CheckBottomFishAssignments){
                        Factors<-c("GTY_Code","Flag_CTY_Code","TFN")
                        LevelCombinations<-unique(CSBdata[,Factors])
                        apply(LevelCombinations,1,fnCatch_summary
                              ,CSBdata,Factors,BFTaxa,Threshold=10)
                        } # end if

# add location following inspection and creating a CSV file with relevant assignment from first step: data_Location_B_M_Step_1

dfTmp1<-merge(CSBdata,data_Location_B_M_Step_1,by=c("GTY_Code","Flag_CTY_Code","TFN"))

```
  
**Step 2**:  The Soviet Union data for unassigned otter trawls were examined by the combination of three factors - target fishery (only groundfish and krill were represented), CCAMLR catch reporting areas, and year.  For the groundfish fishery, some combinations were dominated by krill with comparatively few groundfish represented.  These were assigned to midwater trawling, with the remainder assigned to bottom fishing.
  
```{r GTstep2,echo=FALSE}
# check OT,SUN,TFN=c(1,7) in more detail as still uncertain - once done, this code can be turned off with logical

                       CheckSUN_OTassignments<-FALSE
                       if(CheckSUN_OTassignments){
                                                dfSUN<-CSBdata[CSBdata[,"GTY_Code"]=="OT" 
                                     & CSBdata[,"Flag_CTY_Code"]=="SUN"
                                     & CSBdata[,"TFN"] %in% c(1,7),]
                         Factors<-c("GTY_Code","Flag_CTY_Code","TFN","GAR_Code","Calendar_Year")
                         LevelCombinations<-unique(dfSUN[,Factors])
                         apply(LevelCombinations,1,fnCatch_summary
                               ,dfSUN,Factors,BFTaxa,Threshold=10)
                         } # end if

# modify location following inspection of SUN data for OT and creating a CSV file with relevant assignment from second step: data_Location_B_M_Step_2

dfTmp2<-merge(dfTmp1,data_Location_B_M_Step_2,by=c("GTY_Code","Flag_CTY_Code","TFN","GAR_Code","Calendar_Year"),all.x=TRUE)
dfTmp2[dfTmp2[,"Location.x"]=="U","Location.x"]<-dfTmp2[dfTmp2[,"Location.x"]=="U","Location.y"]
dimnames(dfTmp2)[[2]][dimnames(dfTmp2)[[2]]=="Location.x"]<-"Location"
CSBdata<-dfTmp2[,-which(dimnames(dfTmp2)[[2]] %in% "Location.y")]
GTY_rev<-CSBdata[,"GTY_Code"]
GTY_rev[GTY_rev=="OT"]<-unlist(lapply(CSBdata[GTY_rev=="OT","Location"],function(g){paste("OT",g,sep="")}))
CSBdata<-cbind(CSBdata,GTY_rev)

remove("dfTmp1")
remove("dfTmp2")
remove("GTY_rev")

```




```{r plotGearTypeRev, out.width="70%", fig.cap="*Total catch (tonnes, all taxa) for each major gear type in the CCAMLR area in each decade from the 1960s to the present, derived from the CCAMLR Statistical Bulletin 2019 with Otter Trawl Nei assigned to bottom or midwater (see text for details))*", fig.show='hold', fig.align='center', echo=FALSE}

# plot revised assignments
if(plotGearTypeRev){
res1<-data.frame(Decade=10*(floor(CSBdata[,"Calendar_Year"]/10))
                ,Gear=GT_Names[match(CSBdata[,"GTY_rev"],GT_Names[,"Gear"]),"GTn"]
                ,Tonnes = CSBdata[,"Green_Weight"])
res1<-rbind(res1,GTzeros)
res<-as.data.frame(aggregate(res1[,"Tonnes"],list(res1[,"Decade"],res1[,"Gear"]),sum))
dimnames(res)[[2]]<-c("Decade","Gear","Tonnes")
remove("res1")

# exclude data
GTY_exclude<- GT_Names[match(c("TX","TBB","OT"),GT_Names[,"Gear"]),"GTn"]     
res<-res[!(res[,"Gear"] %in% GTY_exclude),]
pGT_Names<- GT_Names[-(match(GTY_exclude,GT_Names[,"GTn"])),] 

plotYlog<-TRUE

if(plotYlog){
  res[res[,"Tonnes"]<1,"Tonnes"]<-1
   }

p <- ggplot()
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid"))

p<- p+ geom_col(res, mapping = (aes(x = factor(res[,"Decade"]), y = res[,"Tonnes"], fill = factor(res[,"Gear"]))),position = position_dodge(preserve = 'single'))
p <- p + labs(x = "Decade", y ="Tonnes", fill = "Gear",title="Total catch by decade for gear type with assigned OT")
if (plotYlog) p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = c(1E0,1E8)) + annotation_logticks(sides="l")
p <- p + scale_fill_discrete(name = "Gear", breaks=levels(factor(res[,"Gear"]))
                             ,labels = CRfishingGear[match(pGT_Names[
                                            match(as.character(pGT_Names[,"GTn"]),levels(factor(res[,"Gear"])))
                                            ,"Gear"],CRfishingGear[,"GTY_Code"]),"GTY_Name"]
                             ,type=pGT_Names[,"Colour"]) # change legend labels

p
} # end if plotGearTypeRev

if(PlotToFile) ggsave("Catch_Gear_Type_Decade.tiff",width=15,height=10,units="cm")

```
  

A revised GTY code is added to the main data frame along with an assignment of all fisheries to a location in the water column in which the gear was deployed:

**GTY_rev**    Revised GTY_Code to replace OT code  
**Location**   Gear deployed on or near to the bottom (B) or midwater (M).  
  
  
    
### Nations

[Under development]

```{r NationsSetup, echo=FALSE, eval=FALSE}


                      CheckSUN_OTassignments<-FALSE
                       if(CheckSUN_OTassignments){
                                dfSUN<-CSBdata[CSBdata[,"Flag_CTY_Code"]=="SUN" &
                                               (CSBdata[,"GAR_Code"]=="48"),]
                         Factors<-c("GTY_Code","TFN","GAR_Code","Split_Year")
                         LevelCombinations<-unique(dfSUN[,Factors])
                         apply(LevelCombinations,1,fnCatch_summary
                               ,dfSUN,Factors,BFTaxa,Threshold=2)
                         remove("dfSUN")
                         } # end if

                  

CheckStatAreaAssignments<-FALSE
if(CheckStatAreaAssignments){
dfcombo<-CSBdata[,] # CSBdata[,"GAR_Code"] %in% c("48","58","88")
  Factors<-c("GTY_Code","GTY_rev","Flag_CTY_Code","TFN","GAR_Code","Split_Year")
  LevelCombinations<-unique(dfcombo[,Factors])
  apply(LevelCombinations,1,fnCatch_summary
        ,dfcombo,Factors,BFTaxa,Threshold=10)
  remove("dfCombo")
  } # end if



##################################################################################################
tempContinue<-FALSE
if(tempContinue){

# check catches by species
cat("Total catch of individual taxa (where a catch in one year by a nation of the taxon :",sep="")
  df<-aggregate(df2[,"Tonnes"],by=list(df2[,"Nation"]),sum)
  dimnames(df)[[2]]<-c("Nation","Tonnes")

# determine first and last years

  TrawlGfish_CTY<-df[,"Nation"]
  YearFirst<-unlist(do.call(rbind,lapply(TrawlGfish_CTY,function(c,dCSB){min(dCSB[dCSB[,"Nation"]==c,"Year"])},df2)))
  YearLast <-unlist(do.call(rbind,lapply(TrawlGfish_CTY,function(c,dCSB){max(dCSB[dCSB[,"Nation"]==c,"Year"])},df2)))
df<-cbind(df,YearFirst,YearLast)

# add zeros for each Nation*Decade 
decade<-seq(1960,2010,10)
CTzeros<-do.call(rbind,lapply(seq(1,length(decade),1),function(t,decade,CT){return(data.frame(Decade=rep(decade[t],length(CT)),Country=CT,Tonnes=rep(0,length(CT))))},decade,CTY_Names[,"CTn"]))

res1<-data.frame(Decade=10*(floor(CSBdata[,"Calendar_Year"]/10))
                ,Gear=GT_Names[match(CSBdata[,"GTY_Code"],GT_Names[,"Gear"]),"GTn"]
                ,Tonnes = CSBdata[,"Green_Weight"])
res1<-rbind(res1,GTzeros)
res<-as.data.frame(aggregate(res1[,"Tonnes"],list(res1[,"Decade"],res1[,"Gear"]),sum))
dimnames(res)[[2]]<-c("Decade","Gear","Tonnes")




  
  
  p <- ggplot(df, aes(x = factor(df[,"Nation"]), y = df[,"Tonnes"], fill = factor(df[,"Country"])))
  p <- p + geom_col(position = "dodge")
  p <- p + labs(x = "Gear", y ="Tonnes", fill = "Country",title=paste(CatchTaxon[ct]," catch by gear for countries",sep=""))
  p<-p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = c(1E0,1E8)) + annotation_logticks(sides="l")
  p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid"))
  p
  
 plots<- c(plots,list(p))
 
} # end tempContinue



```

```{r WorldMap, echo=FALSE}
# Countries WGS84 from ArcGIS Hub
# (https://hub.arcgis.com/datasets/a21fdb46d23e4ef896f31475217cbb08_1?geometry=-120.937%2C-89.983%2C120.937%2C-88.772)

World <- rgdal::readOGR(dsn=paste(RootDir,"maps/shapefiles/Longitude_Graticules_and_World_Countries_Boundaries-shp",sep=""), layer="99bfd9e7-bb42-4728-87b5-07f8c8ac631c2020328-1-1vef4ev.lu5nk")

CNTRY_names<-World$CNTRY_NAME
CNTRY_n<-CNTRY_names


# match country codes in CSBdata and names in World Map

CR_Flag_CTY<-CRcountry[ which(CRcountry[,"CTY_Code"] %in%  unique(CSBdata[,"Flag_CTY_Code"])),]
CR_Flag_CTY<-cbind(CR_Flag_CTY,CR_Flag_CTY[,"CTY_Name"])
dimnames(CR_Flag_CTY)[[2]]<-c("CTY_Code","Name","World_Name")

WorldNames<-matrix(c("GBR","United Kingdom"
                    ,"SUN","Russia-Ukraine"
                    ,"KOR","South Korea"
                    ,"DDR","Germany"
                    ,"USA","United States"
                    ,"DEU","Germany"
                    ,"RUS","Russia"
                    ,"CHN","China"),ncol=2,byrow=TRUE,dimnames=list(NULL,c("CTY_Code","World_Name")))
whereReplaceName <- which(CR_Flag_CTY[,"CTY_Code"] %in% WorldNames[,1])
CR_Flag_CTY<-bind_rows(CR_Flag_CTY[-whereReplaceName,]
                       ,merge(CR_Flag_CTY[whereReplaceName,c(1,2)],WorldNames,by="CTY_Code"))
CR_Flag_CTY<-CR_Flag_CTY[order(CR_Flag_CTY[,"World_Name"]),]


```

```{r plotWorldScience, echo=FALSE, eval=FALSE}

WebOfScience_CTY<-read.csv("WebOfScience1970-2020 Antarctic & SO.csv")

# aggregate by WorldNames

WoSrecords<-aggregate(WebOfScience_CTY[,"records"],list(WebOfScience_CTY[,"WorldNames"]),sum)
dimnames(WoSrecords)[[2]]<-c("WorldNames","Records")

WoSCTY_attr<-rep(NA,length(CNTRY_names))
WoSCTY_attr[match(WoSrecords[,"WorldNames"],CNTRY_names)]<-WoSrecords[,"Records"]
World$Records<-WoSCTY_attr

#pmap<-ggplot() + geom_polygon(data = World, aes(x = long, y = lat))
#pmap

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                              fill = Records))
p<-p+geom_polygon() + scale_fill_continuous(type="gradient")
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Records"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Scientific Papers", fill = "Records")
p

if(PlotToFile) ggsave("Scientific_Papers_State.tiff",width=15,height=10,units="cm")

```

## Rules for distributing catches between MEASO reporting areas


```{r DCprepare,echo=FALSE}

# some routines for summarising data in preparing for rules

CheckRecords<-FALSE
if(CheckRecords){
dfcombo<-CSBdata[CSBdata[,"Catch_TXN_Code"] %in% c("WIC"),]
  Factors<-c("Flag_CTY_Code","GAR_Code")
  LevelCombinations<-unique(dfcombo[,Factors])
  apply(LevelCombinations,1,fnCatch_summary
        ,dfcombo,Factors,BFTaxa,Threshold=10)
 remove("dfcombo")
    } # end if

```


```{r DCfunctions,echo=FALSE}


fnDistributeCatch<-function(c,CD,dCSB){
           subCSB<-dCSB[CD[[c]]$Subset,]
           res<-bind_rows(lapply(subCSB[,"Green_Weight"],function(gw,subD){gw*subD},CD[[c]]$Distribution))
           rule<-as.data.frame(matrix(CD[[c]]$Rule,ncol=1,nrow=nrow(subCSB),dimnames=list(NULL,"Rule")))
           return(bind_cols(subCSB,rule,res))
           }
```


Catch records in the Bulletin were reviewed by split year and grouped by ASD area, Flag Country, Gear type (revised as above), Fishery, and Taxa with annual catches by country greater than 10 tonnes (assumed to relate to commercial quantities of groundfish or toothfish).  

The spatial distribution of fisheries are described in CCAMLR reports since 1990, particularly fishery reports for toothfish, mackerel icefish and Antarctic krill (http://fisheryreports.ccamlr.org/).  Catch reports that were aggregated across a number of ASD areas prior to 1990 had their the last year of reports as follows:

  - only by Statistical Areas 48 (Atlantic), 58 (Indian), and 88 (Pacific) by the main fishing nations were the split-years 1986, 1979, 1986 respectively. Latvia had a single reported fishing year for a low catch of krill in Area 48 in 1993.
  - only by Subarea 58.4 and 58.5 ended in 1987 and 1988 respectively
  - only by 58.4.3 and 58.4.4, ended by 1999 and 1980 respectively.
  
  
```{r CatchDistSetup, echo=FALSE}
########## Seabed areas #############################################

Seabed_areas <- readRDS(Seabed_file)
# give each cell an area of 2x2 km until it is available in input file
Seabed_areas<-cbind(Seabed_areas,rep(4,nrow(Seabed_areas)))

# rename variables to be consistent with code
dimnames(Seabed_areas)[[2]]<-c("Lon","Lat","Cell","Depth","Iceshelf","MEASO","ASD","SSRU","SSMU","Area")

Cbed_rules<-Seabed_areas[!(Seabed_areas[,"Iceshelf"]) & !is.na(Seabed_areas[,"ASD"]) 
                         & !is.na(Seabed_areas[,"MEASO"]),c("Cell","Lon","Lat","Depth","MEASO","ASD","SSMU","SSRU","Area")]
Cbed_rules[is.na(Cbed_rules[,"SSRU"]),"SSRU"]<-"NA"
Cbed_rules[is.na(Cbed_rules[,"SSMU"]),"SSMU"]<-"NA"

remove(Seabed_areas)  # free up memory


###############################################################
      
      

CatchDistRules <- fnSetupCatchDistRules(
                      CSBdata
                     ,Depth_intervals
                     ,Cbed_rules
                     ,AreaGroups
                     ,MEASOareas[,"Code"]
                     ,ASDareas[,"Code"]
                     ) # end fn call

RuleNames<-unlist(lapply(CatchDistRules,function(CDR){return(CDR$Rule)}))
RuleStatAreas<-unlist(lapply(CatchDistRules,function(CDR){return(CDR$ASDstatArea)}))

```

This section describes the process and subsequent rules for dividing catches in the Bulletin among MEASO areas.  The northern limit of the CCAMLR Convention area more or less follows the path of the Polar Front.  The MEASO Subantarctic Zone extends from the Subantarctic Front to the Southern ACC Front, between which lies the Polar Front.  Apart from the Indian Sector, the Northern Zone of the MEASO is not of importance to CCAMLR.  In the Indian Sector, CCAMLR's Subarea 58.7 overlaps with the Norther Zone because that subarea encompasses the Prince Edward and Marion Islands and most of the Delcano Rise.  
  
The MEASO and CCAMLR areas are shown with their naming conventions in Figure \@ref(fig:CCAMLR-MEASO-areas).  
  
  
```{r CCAMLR-MEASO-areas, out.width="40%", fig.cap="*CCAMLR statistical reporting areas (left) and MEASO areas (right - red lines indicate zones, black dashed lines indicate sectors)*", fig.show="hold", fig.align='center', echo=FALSE}
if(printMaps) knitr::include_graphics(c("CCAMLR_areas.png","MEASO_areas.png"))
```

```{r,echo=FALSE}
kable(MEASOareas,format="simple",align="l",row.names=NA,caption="Description of MEASO areas.")
```

```{r,echo=FALSE}
kable(MEASOareas,format="simple",align="l",row.names=NA,caption="Description of CCAMLR reporting (ASD) areas.")
```

    
The MEASO areas do not perfectly align with CCAMLR areas (Figure \@ref(fig:CCAMLR-MEASO-overlay)).  



```{r CCAMLR-MEASO-overlay, out.width="70%", fig.cap="CCAMLR statistical reporting areas (blue) overlaid on the MEASO areas (red lines)", fig.align='center', echo=FALSE}
if(printMaps) knitr::include_graphics("MEASO-CCAMLR_combined_areas.png")
```

  
The remaining subsections describe the general attributes of fisheries in the three CCAMLR Statistical Areas 48 (Atlantic), 58 (Indian) and 88 (Pacific), and the development of rules for distributing catch in those areas into MEASO areas.  
  
     
#### Area 48  
  
Area 48 has had the most fishing activity in the CCAMLR area, historically concentrated in Subareas 48.1, 48.2 and 48.3.
  
**Subarea 48.1** is split between the Atlantic sector and the East Pacific sector at the eastern tip of Joinville Island with a line crossing the Drake Passage.  The Atlantic sector includes the eastern margin of the Antarctic Peninsula and the shelf to the east of Joinville Island and around Elephant Island.  Bransfield Strait, the western margin of the Antarctic Peninsula and the South Shetland Islands are included in the East Pacific Sector.  The Atlantic sector within the subarea is wholly within the Antarctic zone.  The component of the subarea in the East Pacific Sector has parts in the Antarctic and Subantarctic Zones. Bottom trawl fishing around Joinville Island is included in the East Pacific.  Bottom trawling around Elephant Island is included in the Atlantic.  All fisheries are in the Antarctic Zone.  
  
**Subarea 48.2** is in the Atlantic sector with a slim northern margin crossing into the Subantarctic Zone.  All the fishing areas in this subarea are in the Antarctic zone.  
  
**Subarea 48.3** is in the Atlantic sector with the Southern ACC Front extending from the east of the area to the north and west before returning to the east.  The island, shelf and bank areas sit predominantly in the Subantarctic Zone.  Fishing for bentho-pelagic finfish has occurred primarily in shelf areas.  Myctophid fishing has occurred in the north of the subarea near Morris Ewing Bank.  Krill fishing occurs primarily on the northern shelf slope. All fisheries occur in the Subantarctic Zone.  Occasionally, krill fishing has been reported to occur in the Antarctic Zone [@RN13712].  
  
**Subarea 48.4** is in the Atlantic sector.  The islands and shelf areas are within the Antarctic Zone, while the northern area is in the Subantarctic Zone.  All fisheries occur in the Antarctic Zone.  
  
**Subarea 48.5** is in the Atlantic sector and wholly within the Antarctic Zone.  
  
**Subarea 48.6** is in the Atlantic sector.  The island and shelf areas in the northern part of this subarea are primarily within the Antarctic Zone, although some deeper water areas below 1000 m lie in the Subantarctic Zone.  All fisheries occur in the Antarctic Zone.  
  
Early bottom fisheries in this area spread across Subareas 48.1, 48.2 and 48.3.  For the most part, trawl fisheries were identified to be concentrated from 100-600 m in depth.  Longline fisheries occur in 600m to 1800m in depth.  
  
While not ideal, catches aggregated at the level of Statistical Area were assigned to subareas according to the proportions of trawlable seabed area across Subareas 48.1, 48.2 and 48.3 [@RN6645].  
- Subarea 48.1, @RN6645 shows the trawl fisheries concentrated on the shelf to the north west of the South Shetland Islands, and to the northeast of Joinville Island.  The fishing grounds around the SSI are approximated by the CCAMLR Small-scale Management Units (SSMUs) of Drake Passage West, Drake Passage East, and Elephant Island.  The grounds around Joinville Island are in the eastern margins of two SSMUs - Bransfield Strait East and Antarctic Peninsula East.  The fishing grounds were approximated to be in the area to the north and east of Joinville Island within these SSMUs and bounded to the west by the meridian 56oW and to the south by the latitude 63.3S.  
- Subarea 48.2, @RN6645 shows the trawl fisheries were in areas corresponding to two SSMUs - South Orkney West and South Orkney North East.  
- Subarea 48.3, the trawl fisheries explored all available sea bed within the depth range.  
  
Fishing grounds in Subareas 48.2 and 48.3 fall within the Antarctic Zone and Subantarctic Zones respectively in the Atlantic Ocean sector.  Subarea 48.1 was separated into the Atlantic and East Pacific Sectors of the Antarctic Zone according to the locations of trawlable seabed in that area.  
  
For longline fisheries, the following considerations applied:  
- Chilean pot fishing research in 1998 is listed as a longline fishery in the Bulletin data.  It was concentrated in Subarea 48.1 around Elephant Island and the South Shetland Islands.  The SSMUs in these areas, as for trawl fishing, were used but with the depth range for longline fishing to calculate the proportion of area in each sector.  
- Subarea 48.6 was divided into northern and southern fisheries at 60oS.  This Subarea primarily falls in the Antarctic Zone of the Atlantic Sector.  Catches were assumed to be in the Antarctic Zone. 


Krill fishing in the 1970s occurred in Areas 48 and 58.  During this period, the Soviet Union fishing vessels would fish for krill if the catches of finfish were poor [@RN6645]. In order to distribute the catch by the Soviet Union attributed to Area 48, the spatial pattern adopted for bottom fishing was adopted here, with the proportion of catches in the different MEASO areas determined by seabed areas for krill fishing in SSMUs in Subarea 48.1 (APDPW, APDPE, APEI, and the northeast part of APBSE), Subarea 48.2 (SOW,SONE) and depths in Subarea 48.3. The depth range of 300-1000 m was approximated from the analyses in @RN13713

Distribution of midwater catches between MEASO areas was only ambiguous for Subarea 48.1.  Given the expansion of interest in krill fishing, catches were distributed between the East Pacific Antarctic area from the Atlantic Antarctic area according to the distribution of the depth strata.

While krill fisheries concentrated near to South Georgia.  Myctophid fisheries were attempted in the northern part of Subarea 48.3, the area of which was surveyed in the late 1980s [@RN4306].  Both these fisheries occur in the Subantarctic Zone.
  
  
```{r CD_Area48, include=FALSE, echo=FALSE}
StatArea<-48
AreaRules<-which(RuleStatAreas %in% StatArea)
pdf <- bind_rows(lapply(AreaRules,function(r,CDR){return(
                bind_cols(data.frame(Rule = CDR[[r]]$Rule
                                    ,Description = CDR[[r]]$Description)
                                    ,CDR[[r]]$Distribution))
                                    },CatchDistRules))
#print.data.frame(pdf[order(pdf[,"Rule"]),],row.names=FALSE,right=FALSE)

```
```{r , echo=FALSE}
pStatArea<-"Area 48"
printCols<- c(1,2)
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l","l"),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))
```


```{r , echo=FALSE}

printCols<- (-which(dimnames(pdf)[[2]] %in% c("Description","Outside")))
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l",rep("c",(length(printCols)-1))),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))

```


#### Area 58   
  
Catches in Area 58 have been reported as coming from the whole area, from subareas, and from the divisions within subareas.  
  
**Subarea 58.4** is split between the Central Indian Sector and the East Indian Sector.  It also crosses the Antarctic and Subantarctic Zones.  Krill fishing is contained within the Antarctic Zone.  Finfishing has occurred in both zones, although groundfish fisheries prior to longlining primarily occurred in the Subantarctic Zone.  
  
*Division 58.4.1* crosses between the Central Indian Sector and the East Indian Sector at 115oE, and is mostly in the Antarctic Zone.  The northern part of this division is in deep water in the Subantarctic Zone.  All fisheries occur in the Antarctic Zone.  
  
*Division 58.4.2* falls within the Central Indian Sector and the Antarctic Zone.  A small deep water area in the north east of this division is in the Subantarctic Zone.  All fisheries occur in the Antarctic Zone.  
  
*Division 58.4.3a* is in the Central Indian Sector and falls almost entirely in the Subantarctic Zone.  
  
*Division 58.4.3b* is in the Central Indian Sector and falls mostly in the Subantarctic Zone. The deeper eastern margin of BANZARE Bank is in the Antarctic Zone. Finfish fisheries occur in the Subantarctic Zone.  
  
*Division 58.4.4a* is in the Central Indian Sector.  It is split between the Antarctic Zone where krill fishing occurs and the Subantarctic Zone where finfishing has occurred on the Ob seamount.  
  
*Division 58.4.4b* is in the Central Indian Sector.  It is split between the Antarctic Zone where krill fishing occurs and the Subantarctic Zone where finfishing has occurred on the Lena and other seamounts.  
  
**Subarea 58.5** contains two divisions (58.5.1, 58.5.2) and is in the Central Indian Sector, falling mostly in the Subantarctic Zone.  The deep water northeast corner of Division 58.5.1 sits in the Northern Zone. All fisheries occur within the Subantarctic Zone.  
  
**Subarea 58.6** is in the Central Indian Sector, falling mostly in the Subantarctic Zone.  The northwest corner over Delcano Rise is in the Northern Zone.  
  
**Subarea 58.7** is in the Central Indian Sector.  It is split between the Subantarctic Zone and the Northern Zone.  Most shallow water area is around the islands and shelf area in the Northern Zone. Fisheries occur in the Northern Zone.  
  

 
@RN6645 describes the early fisheries in the Indian Sector as being dominated by finfish fishing in the Subantarctic Zone, primarily around Kerguelen Islands and Ob and Lena Banks.  Krill fishing also occurred in the Antarctic Zone in Prydz Bay.  While some fishing occurred on *Chaenodraco wilsoni* in the Antarctic Zone, which may have occurred in Divisions 58.4.1 and 58.4.2, the main fisheries occurred in the Central Indian Sector.  
  
Records containing both Antarctic krill and the finfish taxa from the Subantarctic Zone need to be separated between the zones rather than distributing each of the taxa between zones.  These records were duplicated by removing Antarctic krill and other taxa that were from the Antarctic Zone from the main record and then creating a record for the Antarctic Zone taxa.  The distribution rules for each of these adjusted records were to allocate the whole catch to their respective zones.  
  
For longline fisheries, Division 58.4.1 is the only ASD area which crosses two sectors.  The longline fishery is wholly within the Antarctic Zone.  Until recently, longline fisheries in this division were constrained to three Small-scale research units - 5841C, 5841E, 5841G.  5841A was open also but comprised only a few seamounts.  Relative proportions of seabed area across these SSRUs in the two sectors is used to divide the catch.  
  
  
```{r CD_Area58, include=FALSE, echo=FALSE}
StatArea<-58
AreaRules<-which(RuleStatAreas %in% StatArea)
pdf <- bind_rows(lapply(AreaRules,function(r,CDR){return(
                bind_cols(data.frame(Rule = CDR[[r]]$Rule
                                    ,Description = CDR[[r]]$Description)
                                    ,CDR[[r]]$Distribution))
                                    },CatchDistRules))
# print.data.frame(pdf[order(pdf[,"Rule"]),],row.names=FALSE,right=FALSE)

```


```{r , echo=FALSE}
pStatArea<-"Area 58"
printCols<- c(1,2)
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l","l"),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))
```


```{r , echo=FALSE}

printCols<- (-which(dimnames(pdf)[[2]] %in% c("Description","Outside")))
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l",rep("c",(length(printCols)-1))),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))

```


#### Area 88  
  
Early fishing interest in Area 88 was in the western margins around the Balleny Islands.  
  
**Subarea 88.1** crosses between the East Indian Sector and the West Pacific Sector at Cape Adare, and is mostly in the Antarctic Zone.  The northern part of this subarea is in deep water in the Subantarctic Zone. All fisheries occur in the Antarctic Zone.  
  
**Subarea 88.2** crosses between the West Pacific Sector and the East Pacific Sector at 125oW, and is mostly in the Antarctic Zone.  The northeast part of this subarea in the East Pacific Sector is in deep water in the Subantarctic Zone. All fisheries occur in the Antarctic Zone.  
  
**Subarea 88.3** is in the East Pacific Sector.  It is split between the Antarctic and Subantarctic Zones with shallow areas occurring almost entirely in the Antarctic Zone. All fisheries occur in the Antarctic Zone.  

  
Bottom trawling appears in the records for Area 88 infrequently.  In 1978, Poland undertook bottom trawling.  When the records were examined closely and in monthly sequence with Subarea 48.1, it was apparent that, given the small catch, this was likely research in the Bellingshausen Sea extending the west Antarctic Peninsula research fishing into Subarea 88.3.  The other bottom trawling to occur was a trawl survey by NZ in during the Census of Antarctic Marine Life in Subarea 88.1 the Ross Sea.  
  
Longline fishing began in Subarea 88.1 in 1997.  In the first two years it was undertaken south of 65oS in the Ross Sea.  In 1999, Small-scale Research Units (SSRUs) were established by CCAMLR (SC-CAMLR, 1999, Table 6).  These were revised over a number of years but Cape Adare was used as one of the dividing lines of these SSRUs.  Until the establishment of the MPA in the Ross Sea in 2016, the management of the longline fishery was via the SSRUs in Subarea 88.1 and SSRUs A and B in Subarea 88.2.  The component of Subarea 88.1 in the East Indian Sector has been closed since the 2005/06 season with it mostly closed prior to that.  For this reason, longline catches in Subarea 88.1 are allocated to the West Pacific Sector in the Antarctic Zone.  
  
For Subarea 88.2, longline fishing has been primarily in the eastern margins related to the Amundsen Sea, with catches allowed in SSRUs C-G.  The crossover between the West and East Pacific Sectors occurs in SSRU 882E, which also has the highest allocation of catch among the SSRUs in the Subarea.  Given that access was dependent on variability in the sea ice, the distribution of catches in this subarea was according to the proportions of seabed for longline fishing among SSRUs C-G.  
  
For Subarea 88.3, Korea has been undertaking a longline research program since their proposal was submitted to SC-CAMLR in 2015.  It is undertaken in research blocks in the Antarctic Zone of the East Pacific Sector.

  
```{r CD_Bottom_Area88, include=FALSE, echo=FALSE}
StatArea<-88
AreaRules<-which(RuleStatAreas %in% StatArea)
pdf <- bind_rows(lapply(AreaRules,function(r,CDR){return(
                bind_cols(data.frame(Rule = CDR[[r]]$Rule
                                    ,Description = CDR[[r]]$Description)
                                    ,CDR[[r]]$Distribution))
                                    },CatchDistRules))
#print.data.frame(pdf[order(pdf[,"Rule"]),],row.names=FALSE,right=FALSE)
```


```{r , echo=FALSE}
pStatArea<-"Area 88"
printCols<- c(1,2)
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l","l"),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))
```


```{r , echo=FALSE}

printCols<- (-which(dimnames(pdf)[[2]] %in% c("Description","Outside")))
kable(pdf[order(pdf[,"Rule"]),printCols],format="simple",align=c("l",rep("c",(length(printCols)-1))),row.names=NA,caption=paste("Proportional distribution of catches for each rule to each of the MEASO areas in ",pStatArea,sep=""))

```


## Catches by Key Taxonomic Groups

Catch data for individual taxa were grouped for reporting here.


```{r,echo=FALSE}
kable(BFTaxa,format="simple",align="l",row.names=NA,caption="Assignment of taxa to groups for reporting catch")
```
  

  
### Toothfish  
  
```{r Catcth_toothfish_setup, echo=FALSE}

CatchTaxa<-c("TOT","TOP","TOA")

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

# to ensure toothfish catch is assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(4,5,6),"Minimum"]<- -100
  DI[c(4,5,6),"Maximum"]<- -600
  
# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the toothfish group for reporting catch")

```
  
  
```{r plotSOmap_toothfish,echo=FALSE,fig.cap="Total catch of toothfish from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Toothfish_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}

SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

#SOleg(c(Cmin,r_small[!is.na(r_small)],Cmax)  # include min and max to fix the colour range
#      , position = "topright", col = rCols
#      , ticks = length(ticks)  #breaks=ticks 
##      ,tlabs = as.character(ticks),#breaks=ticks,
#      ,trim = (SOmapTrimLat+3)
##      , ladj = -2
##      ,lsrt=0
#      , label = "log10 (t/km2)", type = "continuous")

```
  
  
```{r plotTimeSeries_toothfish, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for toothfish (*Dissostichus* spp.) in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])

if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for toothfish (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p


if(PlotToFile) ggsave("Catch_Toothfish_TS.tiff",width=15,height=10,units="cm")

```
  
```{r plotWorld_toothfish, echo=FALSE, fig.cap="Total catches (,000 tonnes) of toothfish over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################

dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")


p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated Toothfish Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Toothfish_Flag_State.tiff",width=15,height=10,units="cm")

```
  
  
### Groundfish  
  
```{r Catcth_groundfish_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(1,2,10,15,16)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa


# to ensure groundfish catch are assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(4,5,6),"Minimum"]<- -100
  DI[c(4,5,6),"Maximum"]<- -600
  
# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the groundfish group for reporting catch")

```
  
  
```{r plotSOmap_groundfish,echo=FALSE,fig.cap="Total catch of groundfish from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Groundfish_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

```
  
  
```{r plotTimeSeries_groundfish, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for groundfish in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for groundfish (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Groundfish_TS.tiff",width=15,height=10,units="cm")


``` 
  
  
```{r plotWorld_groundfish, echo=FALSE, fig.cap="Total catches (,000 tonnes) of groundfish over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################

dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000

World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated groundfish Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Groundfish_Flag_State.tiff",width=15,height=10,units="cm")

```
  
  
### Grenadiers  
  
```{r Catcth_grenadiers_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(6)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa


# to ensure catches are assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(4,5,6),"Minimum"]<- -1000
  DI[c(4,5,6),"Maximum"]<- -2000
  
# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the grenadier group for reporting catch")

```
  
    
```{r plotSOmap_grenadier,echo=FALSE,fig.cap="Total catch of grenadier from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################

######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Grenadier_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()


```
  
  
```{r plotTimeSeries_grenadier, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for grenadier in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for grenadier (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Grenadiers_TS.tiff",width=15,height=10,units="cm")


```
  
    
```{r plotWorld_grenadier, echo=FALSE, fig.cap="Total catches (,000 tonnes) of grenadier over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################

dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated grenadier Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Grenadiers_Flag_State.tiff",width=15,height=10,units="cm")

```
  
    
### Skates and rays  
  
```{r Catcth_skates_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(7)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa


# to ensure catches are assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(4,5,6),"Minimum"]<- -1000
  DI[c(4,5,6),"Maximum"]<- -2000
  
# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-FALSE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
    
      

```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the icefish group for reporting catch")

```
  
  
```{r plotSOmap_skates,echo=FALSE,fig.cap="Total catch of skates and rays from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Skates_Rays_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

```
  
  
```{r plotTimeSeries_skates, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for skates and rays in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for skates and rays (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Skates_Rays_TS.tiff",width=15,height=10,units="cm")


```
  
    
```{r plotWorld_skates, echo=FALSE, eval=FALSE, fig.cap="Total catches (,000 tonnes) of skates and rays over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################

dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated skates and rays Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Skates_Rays_Flag_State.tiff",width=15,height=10,units="cm")

```
  
    
### Icefish  
  
    
```{r Catcth_icefish_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(3,9)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa

# to ensure icefish catches are assigned to correct depth range when reported as bycatch
# in pelagic fisheries

  DI[c(4,5,6),"Minimum"]<- -100
  DI[c(4,5,6),"Maximum"]<- -700
  
# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-TRUE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)


```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the icefish group for reporting catch")
```
  
    
```{r plotSOmap_icefish,echo=FALSE,fig.cap="Total catch of icefish from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Icefish_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

```
  
  
```{r plotTimeSeries_icefish, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for icefish in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for icefish (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Icefish_TS.tiff",width=15,height=10,units="cm")


```
  
    
```{r plotWorld_icefish, echo=FALSE, fig.cap="Total catches (,000 tonnes) of icefish over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################
dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated icefish Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Icefish_Flag_State.tiff",width=15,height=10,units="cm")

```
  
  
### Silverfish and myctophids  
  
```{r Catcth_mesopelagic_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(12,14)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa



# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-TRUE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)


```
  
  
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)

```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the mesopelagic fish group for reporting catch")

```

```{r plotSOmap_mesopelagic,echo=FALSE,fig.cap="Total catch of mesopelagic fish from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Mesopelagics_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

```
  
  
```{r plotTimeSeries_mesopelagic, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for mesopelagic fish in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for mesopelagic fish (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Mesopelagic_TS.tiff",width=15,height=10,units="cm")


```
  
    
```{r plotWorld_mesopelagic, echo=FALSE, fig.cap="Total catches (,000 tonnes) of mesopelagic fish over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################
dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch

WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")

p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))
p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated mesopelagic fish Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Mesopelagic_Flag_State.tiff",width=15,height=10,units="cm")

```
  
    
### Krill  
  
```{r Catcth_krill_setup, echo=FALSE}

CatchTaxa<- BFTaxa[which(BFTaxa[,"Catch_Group"] %in% c(13)),"Code"]

DI<-Depth_intervals  # for altering depth intervals as needed for individual taxa


# for time series plots
  
  removeLastYear<-TRUE
includeZeroCatch<-TRUE
plotYlog<-TRUE
YtickMajor<-5000
YtickMinor<-1000
YtickMinorN<-YtickMajor/YtickMinor-1

XtickMajor<-10
XtickMinor<-1
XtickMinorN<-XtickMajor/XtickMinor-1

Xlimits<-c(1970,2020)

```
  
  
```{r ,echo=FALSE}
### codeCatchProcess ######

CatchDistRules <- fnSetupCatchDistRules(
  CSBdata
  ,DI
  ,Cbed_rules
  ,AreaGroups
  ,MEASOareas[,"Code"]
  ,ASDareas[,"Code"]
) # end fn call

####################################################
# add allocation to CSBdata

Res<-bind_rows(lapply(seq(1,length(CatchDistRules),1),fnDistributeCatch,CatchDistRules,CSBdata))

####################################################
# check all records are accounted for

if(nrow(Res)!=nrow(CSBdata)) {cat("Only ",nrow(Res)/nrow(CSBdata)*100,"% Bulletin records selected by rules.\n\n",sep="")} else {
  cat("All records from Bulletin selected by application of the rules.\n\n")
}

####################################################
# determine total catch by rules

CatchByRules<-unlist(lapply(seq(1,length(CatchDistRules),1),function(c,CD,dCSB,Taxa){
  subCSB<-dCSB[CD[[c]]$Subset,]
  sum(subCSB[which(subCSB[,"Catch_TXN_Code"] %in% Taxa),"Green_Weight"])
},CatchDistRules,CSBdata,CatchTaxa))


####################################################
# distribute catches to pixels
Pixels    <- rep(0,nrow(Cbed_rules))     # generate vector of zeros for N pixels
RuleZeroArea<-NULL
for(c in seq(1,length(CatchDistRules),1)){ # too memory intensive to do lapply
  if(CatchDistRules[[c]]$Area_km2!=0){
    Density   <- CatchByRules[c]/CatchDistRules[[c]]$Area_km2        # density per km2
    # place value in each relevant pixel according to CbedAreaSubset multiplying by Cbed[,"Area"]
    Pixels[CatchDistRules[[c]]$CbedAreaSubset] <- 
      Pixels[CatchDistRules[[c]]$CbedAreaSubset] + 
      Density  
  } else {
    RuleZeroArea<-c(RuleZeroArea,c,CatchByRules[c])
  }
} # end loop c

cat(cat("Total catch in Bulletin for ("),cat(CatchTaxa,sep=", "),cat("): ", sum(CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),"Green_Weight"])),"\n",sep="")

Resolution<-4 # km2
cat("Catch allocated to pixels: ",sum(Pixels)*Resolution,"\n",sep="") 
if(!is.null(RuleZeroArea)){
cat("Rules with zero area and catch not allocated\n")
print.data.frame(as.data.frame(matrix(RuleZeroArea,ncol=2,byrow=TRUE,dimnames = list(NULL,c("Rule","Catch")))))
} else {
 cat("No areas had rules with zero area, and catch not allocated\n\n") 
}

#prepare catch/pixel for plotting
PixelsLog10<- Pixels
PixelsLog10[PixelsLog10==0]<-NA

#populate the cells indexed from the cell column in template 
r <- template
r[Cbed_rules$Cell] <- log10(PixelsLog10)

# reduce resolution for plotting if needed
r_small<-aggregate(r, fact=4)

rgg<-as.data.frame(r_small,xy=2)

```
  
  
```{r,echo=FALSE}
dfTaxa<-CSB_taxa[match(CatchTaxa,CSB_taxa[,"TXN_Code"]),c("TXN_Code","TXN_Name")]
dimnames(dfTaxa)[[2]]<-c("Code","Name")
kable(dfTaxa[!is.na(dfTaxa[,"Code"]),],format="simple",align="l",row.names=NA,caption="Assignment of taxa to the icefish group for reporting catch")

```
  
    
```{r plotSOmap_Krill,echo=FALSE,fig.cap="Total catch of krill from 1970 to 2018 plotted against ocean depth (bottom left legend) as catch density (tonnes per square kilometer) on a log10 scale (the top right legend).  Source data: CCAMLR Statistical Bulletin 2019.  Bulletin data were allocated according to evidence for fishing depths and locations in reports of the Scientific Committee, CCAMLR Conservation Measures, and various descriptions in the scientific literature, particular Kock (1992).  Catches were spread uniformly across the smallest area identified from those sources for an individual catch based on country, depth range for a given target fishery/gear type, and, where reports allowed it, year.  Grey lines show a graticule.  Red lines show the boundaries of the 15 MEASO areas."}


######### codePlotCatchMap #################
######### codePlotCatchMap #################
# convert rgg$layer to colour
col_pal<-colorRampPalette(c("gold","greenyellow","green","green2","red","darkred")) # from brewer, 

if(SOmapFixBreaks){
  Cmin<- (-9)
  Cmax <- 2
} else {
  Cmin <- floor(min(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  Cmax <- ceiling(max(rgg[(!is.nan(rgg$layer) & !is.na(rgg$layer)),"layer"]))
  } #end fix breaks
Cn   <- 1000
rCols<-col_pal(Cn)
rColour<-rep(NA,length(rgg$layer))
Cvalid<-(!is.nan(rgg$layer) & !is.na(rgg$layer))
rColour[Cvalid]<-rCols[ceiling((rgg$layer[Cvalid]-Cmin)/(Cmax-Cmin)*Cn)]
ticks<-seq(Cmin,Cmax,1)

# now plot
if(PlotToFile) {
  tiff("Catch_Krill_map.tiff",width = 15,height = 10, units = "cm", res=300)
} else {
  frame()
}


SOmap(graticules=TRUE,graticules_col="grey30"
      ,trim=SOmapTrimLat
      #      ,col=NA,border=NA
      ,land=FALSE
      ,ice=FALSE
)
SOplot(measo_shapes,col=NA,border="black",size=0.25, add=TRUE)
SOplot(SOmap::SOmap_data$ant_coast_ice
       ,add=TRUE,col="white",border="grey50",lwd=0.25)

## create a circle
## distance from south pole to -40
width <-  geodist::geodist(data.frame(lon=0, lat= -90), data.frame(lon= 0, lat = SOmapTrimLat), measure = "geodesic")
pContinent<- SOmap::SOmap_data$continent

pContinent <- raster::crop(pContinent, 
   rgeos::gBuffer(SpatialPoints(cbind(0, -90)), width = width))

SOplot(pContinent, add=TRUE, col="grey90",border="black",lwd=0.25)

SOplot(pContinent,add=TRUE,col="grey90",border="black",lwd=0.25)
SOplot(r_small,col=rCols
       ,legend=TRUE
       ,legend.width=1, legend.shrink=0.75
       ,legend.args=list(text='log10(Tonnes.km-2)', side=4, font=2, line=2.5, cex=0.8)
       , zlim=c(Cmin,Cmax),add=TRUE)#, breaks=ticks)

if(PlotToFile) dev.off()

```
  
  
```{r plotTimeSeries_krill, echo=FALSE, fig.cap="Time series of catches (tonnes) from all gear for krill in each of the MEASO areas."}

######### codePlotCatchTimeSeries #################

plotMareas<-as.data.frame(MEASOareas[MEASOareas[,"Code"]!="Outside",c("chOrder","Code","Col","LTY")])
plotMareas<-bind_cols(data.frame(Order = seq(1,nrow(plotMareas),1)),plotMareas)

pdf<-bind_rows(lapply(plotMareas[,"Code"],fnCalcMEASO_TimeSeries,Res,CatchTaxa))
pdf<-bind_cols(pdf,data.frame(
  chOrder  = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"chOrder"]
  ,Sector = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Sector"]
  ,Zone   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Zone"]
  ,Colour   = MEASOareas[match(pdf[,"MEASO"],MEASOareas[,"Code"]),"Col"]
))

pdf<-pdf[order(pdf[,"chOrder"]),]
pMareas<-MEASOareas[match(unique(pdf[,"chOrder"]),MEASOareas[,"chOrder"]),]

if(plotYlog | !includeZeroCatch) pdf[pdf[,"Catch"]<1,"Catch"]<-NA   

if(removeLastYear) pdf<-pdf[pdf[,"Split_Year"]<max(pdf[,"Split_Year"]),]

maxCatch<-max(pdf[!is.na(pdf[,"Catch"]),"Catch"])
minCatch<-min(pdf[!is.na(pdf[,"Catch"]),"Catch"])
if(plotYlog){
  Ylimits<-c(10^floor(log10(minCatch)),10^ceiling(log10(maxCatch)))
} else {
  YmaxVals<-fnYmax(maxCatch)
  Ylimits<-c(0,YmaxVals[1])
  YtickMajor<-YmaxVals[2]
}
pdf$MEASO<-factor(pdf$MEASO,levels = pMareas[,"Code"]) 
Area<-pdf$MEASO

Xlimits<-c(floor(min(pdf[,"Split_Year"])/10)*10,ceiling(max(pdf[,"Split_Year"])/10)*10)


p<-ggplot() 
p<-p +scale_x_continuous(minor_breaks = seq(Xlimits[1],Xlimits[2],by=XtickMinor), breaks = seq(Xlimits[1],Xlimits[2],by=XtickMajor), limits = Xlimits)
if (plotYlog) {
  p <- p + scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x)), limits = Ylimits) + annotation_logticks(sides="l")
} else {
  p<-p +scale_y_continuous(breaks = seq(Ylimits[1],Ylimits[2],by=YtickMajor), minor_breaks = seq(Ylimits[1],Ylimits[2],by=YtickMinor), limits = Ylimits, labels = scales::comma)
  
}

p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_line(colour = "black",size=1, linetype="solid")
               ,axis.ticks.length=unit(0.25,"cm")
)#end theme
#p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = pdf[,"MEASO"], lty = pdf[,"MEASO"])), show.legend=TRUE, name="Area")
p<- p+ geom_line(pdf, mapping = (aes(x = pdf[,"Split_Year"], y = pdf[,"Catch"], col = Area, lty = Area)), show.legend=TRUE)

p <- p + labs(x = "Year", y ="Catch (tonnes)", title="Catch for Krill (all gears)")

p<-p + scale_colour_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"Col"])

p<-p + scale_linetype_manual(values=MEASOareas[match(unique(pdf[,"MEASO"]),MEASOareas[,"Code"]),"LTY"])
p

if(PlotToFile) ggsave("Catch_Krill_TS.tiff",width=15,height=10,units="cm")


```
  
    
```{r plotWorld_krill, echo=FALSE, fig.cap="Total catches (,000 tonnes) of krill over the historical period for each Flag State."}
######### codePlotCatchWorldMap #################
dfSubset<-CSBdata[which(CSBdata[,"Catch_TXN_Code"] %in% CatchTaxa),c("Flag_CTY_Code","Green_Weight")]

dfSubset<-bind_cols(dfSubset,WorldName = CR_Flag_CTY[match(dfSubset[,"Flag_CTY_Code"],CR_Flag_CTY[,"CTY_Code"]),"World_Name"])

WorldCatch<-aggregate(dfSubset[,"Green_Weight"],by=list(dfSubset[,"WorldName"]),sum)
dimnames(WorldCatch)[[2]]<-c("Country","Catch")

# split USSR into catches by Russian and Ukraine according to population size
USSRcatch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),"Catch"]
if(!is.na(USSRcatch)){

  R_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"]
  if(length(R_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Russia")),"Catch"] <- R_Catch+USSRcatch*0.78
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Russia"),Catch=c(USSRcatch*0.78)))  
    } 
  
  U_Catch<-WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"]
  if(length(U_Catch)!=0) {
    WorldCatch[which(WorldCatch[,"Country"] %in% c("Ukraine")),"Catch"] <- U_Catch+USSRcatch*0.22
    } else {
    WorldCatch<-bind_rows(WorldCatch,data.frame(Country = c("Ukraine"),Catch=c(USSRcatch*0.22)))  
    } 

  WorldCatch<-WorldCatch[-which(WorldCatch[,"Country"] %in% c("Russia-Ukraine")),]
  }  # end USSR catch


WcatchCTY_attr<-rep(NA,length(CNTRY_names))
WcatchCTY_attr[match(WorldCatch[,"Country"],CNTRY_names)]<-WorldCatch[,"Catch"]/1000
World$Catch<-WcatchCTY_attr

World$id<-as.numeric(World$OBJECTID)
mapWorld_pts<- fortify(World, region = "id")
mapWorld<-merge(mapWorld_pts,World,by="id")


p <- ggplot(data = mapWorld, aes(x=long, y=lat, group = group,
                                 fill = Catch))

p<-p+geom_polygon() + scale_fill_viridis_c(direction = -1)
p<-p+geom_polygon(data=mapWorld[is.na(mapWorld[,"Catch"]),],mapping=aes(x=long,y=lat),fill="grey90")
p<-p+geom_polygon(data=mapWorld[mapWorld[,"CNTRY_NAME"]=="Antarctica",],mapping=aes(x=long,y=lat),fill="grey90")
p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()
               ,panel.background = element_blank()
               , axis.line = element_blank()
               ,axis.text=element_blank()
               ,axis.ticks=element_blank()
               ,axis.title=element_blank())
p <- p + labs(title="Total accumulated Krill Catch by Flag State", fill = "Catch (,000 tonnes)")
p

if(PlotToFile) ggsave("Catch_Krill_Flag_State.tiff",width=15,height=10,units="cm")

```
  
 
# References    
.     
